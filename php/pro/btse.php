<?php

namespace ccxt\pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\ExchangeError;
use ccxt\AuthenticationError;
use ccxt\BadSymbol;
use ccxt\RateLimitExceeded;
use \React\Async;
use \React\Promise\PromiseInterface;

class btse extends \ccxt\async\btse {

    public function describe(): mixed {
        return $this->deep_extend(parent::describe(), array(
            'has' => array(
                'ws' => true,
                // BTSE does NOT support WebSocket order placement/modification
                // Orders must be placed via REST API only
                'createOrderWs' => false,
                'editOrderWs' => false,
                'cancelOrderWs' => false,
                'cancelAllOrdersWs' => false,
                'watchBalance' => true,
                'watchMyTrades' => true,
                'watchOHLCV' => true,
                'watchOHLCVForSymbols' => true,
                'watchOrderBook' => true,
                'watchOrderBookForSymbols' => true,
                'watchOrders' => true,
                'watchTicker' => true,
                'watchTickers' => true,
                'watchTrades' => true,
                'watchTradesForSymbols' => true,
                'watchPositions' => true,
                'unWatchTicker' => true,
                'unWatchTickers' => true,
                'unWatchOHLCV' => true,
                'unWatchOHLCVForSymbols' => true,
                'unWatchOrderBook' => true,
                'unWatchOrderBookForSymbols' => true,
                'unWatchTrades' => true,
                'unWatchTradesForSymbols' => true,
                'unWatchMyTrades' => true,
                'unWatchOrders' => true,
                'unWatchPositions' => true,
                'unWatchBalance' => true,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => array(
                        'public' => 'wss://ws.btse.com/ws/futures',
                        'orderbook' => 'wss://ws.btse.com/ws/oss/futures',
                        'private' => 'wss://ws.btse.com/ws/futures',
                        'publicSpot' => 'wss://ws.btse.com/ws/spot',
                        'orderbookSpot' => 'wss://ws.btse.com/ws/oss/spot',
                        'privateSpot' => 'wss://ws.btse.com/ws/spot',
                    ),
                ),
                'test' => array(
                    'ws' => array(
                        'public' => 'wss://testws.btse.io/ws/futures',
                        'orderbook' => 'wss://testws.btse.io/ws/oss/futures',
                        'private' => 'wss://testws.btse.io/ws/futures',
                        'publicSpot' => 'wss://testws.btse.io/ws/spot',
                        'orderbookSpot' => 'wss://testws.btse.io/ws/oss/spot',
                        'privateSpot' => 'wss://testws.btse.io/ws/spot',
                    ),
                ),
            ),
            'options' => array(
                'watchOrderBook' => array(
                    'grouping' => '0', // default grouping level (0, 1, 2, 3)
                    'type' => 'snapshotL2', // 'snapshotL1' or 'snapshotL2'
                ),
                'watchPositions' => array(
                    'fetchPositionsSnapshot' => true, // fetch initial snapshot via REST
                    'awaitPositionsSnapshot' => true, // wait for snapshot before providing updates
                ),
                'requestId' => 0, // for generating unique request IDs
            ),
            'streaming' => array(
                // BTSE does not respond to pings, so disable ping/pong keepalive
            ),
        ));
    }

    public function request_id() {
        $requestId = $this->sum($this->safe_integer($this->options, 'requestId', 0), 1);
        $this->options['requestId'] = $requestId;
        return $requestId;
    }

    public function get_url($isPrivate = false, $isOrderbook = false, $market = null) {
        $urls = $this->safe_value($this->urls, $this->options['defaultType'], $this->urls['api']);
        $ws = $this->safe_value($urls, 'ws', array());
        // Determine if this is a SPOT $market
        $isSpot = ($market !== null) && $this->safe_value($market, 'spot', false);
        // Select appropriate endpoint based on $market type
        if ($isOrderbook) {
            return $this->safe_string($ws, $isSpot ? 'orderbookSpot' : 'orderbook');
        } elseif ($isPrivate) {
            return $this->safe_string($ws, $isSpot ? 'privateSpot' : 'private');
        } else {
            return $this->safe_string($ws, $isSpot ? 'publicSpot' : 'public');
        }
    }

    public function authenticate($params = array ()) {
        return Async\async(function () use ($params) {
            $url = $this->get_url(true);
            $client = $this->client($url);
            $messageHash = 'authenticated';
            $future = $this->safe_value($client->subscriptions, $messageHash);
            if ($future === null) {
                $this->check_required_credentials();
                $nonce = $this->nonce();
                $path = '/ws/futures';
                $auth = $path . (string) $nonce;
                $signature = $this->hmac($this->encode($auth), $this->encode($this->secret), 'sha384', 'hex');
                $request = array(
                    'op' => 'authKeyExpires',
                    'args' => array(
                        $this->apiKey,
                        $nonce,
                        $signature,
                    ),
                );
                $future = Async\await($this->watch($url, $messageHash, $request, $messageHash));
            }
            return $future;
        }) ();
    }

    public function ping(Client $client) {
        return array(
            'op' => 'ping',
        );
    }

    public function handle_pong(Client $client, mixed $message): mixed {
        // Message = $this->milliseconds();
    }

    public function handle_message(Client $client, mixed $message) {
        $topic = $this->safe_string($message, 'topic');
        $op = $this->safe_string($message, 'op');
        // Handle operational messages
        if ($op === 'pong') {
            $this->handle_pong($client, $message);
        } elseif ($op === 'subscribe' || $op === 'unsubscribe') {
            $this->handle_subscription_status($client, $message);
        } elseif ($op === 'authKeyExpires') {
            $this->handle_authentication_message($client, $message);
        }
        // Handle data messages by $topic
        if ($topic !== null) {
            if (mb_strpos($topic, 'ticker:') === 0) {
                $this->handle_ticker($client, $message);
            } elseif (mb_strpos($topic, 'snapshotL1:') === 0 || mb_strpos($topic, 'snapshotL2:') === 0) {
                $this->handle_order_book($client, $message);
            } elseif ($topic === 'trades' || mb_strpos($topic, 'trades:') === 0 || mb_strpos($topic, 'tradeHistoryApi') === 0) {
                // BTSE FUTURES uses "tradeHistoryApiV3:BTC-PERP"
                // BTSE SPOT uses "tradeHistoryApi:BTC-USD"
                $this->handle_trades($client, $message);
            } elseif (mb_strpos($topic, 'kline:') === 0) {
                $this->handle_ohlcv($client, $message);
            } elseif ($topic === 'orders') {
                $this->handle_orders($client, $message);
            } elseif ($topic === 'fills') {
                $this->handle_my_trades($client, $message);
            } elseif ($topic === 'positionsV3') {
                $this->handle_positions($client, $message);
            } elseif ($topic === 'wallet') {
                $this->handle_balance($client, $message);
            } elseif ($topic === 'error') {
                $this->handle_error($client, $message);
            }
        }
    }

    public function handle_subscription_status(Client $client, mixed $message): mixed {
        // Handle subscription/unsubscription confirmation
        return $message;
    }

    public function handle_authentication_message(Client $client, mixed $message): mixed {
        $messageHash = 'authenticated';
        $future = $this->safe_value($client->subscriptions, $messageHash);
        if ($future !== null) {
            $future->resolve (true);
        }
        return $message;
    }

    public function handle_error(Client $client, mixed $message): bool {
        // Error format:
        // {
        //   "topic" => "error",
        //   "code" => 4001,
        //   "message" => "Invalid symbol"
        // }
        $code = $this->safe_integer($message, 'code');
        $errorMessage = $this->safe_string($message, 'message');
        if ($code !== null) {
            if ($code === 4001) {
                throw new BadSymbol($errorMessage);
            } elseif ($code === 4003) {
                throw new AuthenticationError($errorMessage);
            } elseif ($code === 4004) {
                throw new ExchangeError($errorMessage); // RateLimitExceeded
            }
            throw new ExchangeError($errorMessage);
        }
        return false;
    }

    public function watch_ticker(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
             *
             * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
             *
             * @param {string} $symbol unified $symbol of the $market to fetch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $url = $this->get_url(false, false, $market);
            $messageHash = 'ticker:' . $symbol;
            $topic = 'ticker:' . $market['id'];
            $request = array(
                'op' => 'subscribe',
                'args' => array( $topic ),
            );
            return Async\await($this->watch($url, $messageHash, $request, $messageHash));
        }) ();
    }

    public function watch_tickers(?array $symbols = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * watches a price $ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
             *
             * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
             *
             * @param {string[]} $symbols unified $symbol of the $market to fetch the $ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=$ticker-structure $ticker structure~
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols, null, false);
            $messageHashes = array();
            $topics = array();
            $firstMarket = null;
            for ($i = 0; $i < count($symbols); $i++) {
                $symbol = $symbols[$i];
                $market = $this->market($symbol);
                if ($i === 0) {
                    $firstMarket = $market;
                }
                $topic = 'ticker:' . $market['id'];
                $topics[] = $topic;
                $messageHashes[] = 'ticker:' . $symbol;
            }
            $url = $this->get_url(false, false, $firstMarket);
            $request = array(
                'op' => 'subscribe',
                'args' => $topics,
            );
            $ticker = Async\await($this->watch_multiple($url, $messageHashes, $request, $messageHashes));
            if ($this->newUpdates) {
                $result = array();
                $result[$ticker['symbol']] = $ticker;
                return $result;
            }
            return $this->filter_by_array($this->tickers, 'symbol', $symbols);
        }) ();
    }

    public function un_watch_ticker(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * unwatch a price ticker
             *
             * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
             *
             * @param {string} $symbol unified $symbol of the market to unwatch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {any} status
             */
            return Async\await($this->un_watch_tickers(array( $symbol ), $params));
        }) ();
    }

    public function un_watch_tickers(?array $symbols = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * unwatch price tickers
             *
             * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
             *
             * @param {string[]} $symbols unified $symbols of the markets to unwatch the tickers for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {any} status
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols, null, false);
            $topics = array();
            $firstMarket = null;
            for ($i = 0; $i < count($symbols); $i++) {
                $symbol = $symbols[$i];
                $market = $this->market($symbol);
                if ($i === 0) {
                    $firstMarket = $market;
                }
                $topic = 'ticker:' . $market['id'];
                $topics[] = $topic;
            }
            $url = $this->get_url(false, false, $firstMarket);
            $request = array(
                'op' => 'unsubscribe',
                'args' => $topics,
            );
            return Async\await($this->watch($url, 'unsubscribe:ticker', $request, 'unsubscribe:ticker'));
        }) ();
    }

    public function handle_ticker(Client $client, mixed $message): mixed {
        //
        // {
        //   "topic" => "ticker:BTC-PERP",
        //   "data" => {
        //     "symbol" => "BTC-PERP",
        //     "last" => "28065.0",
        //     "lowestAsk" => "28065.0",
        //     "highestBid" => "28064.5",
        //     "volume24h" => "123456.78",
        //     "high24h" => "28500.0",
        //     "low24h" => "27500.0",
        //     "timestamp" => 1680751558529
        //   }
        // }
        //
        $data = $this->safe_dict($message, 'data', array());
        $ticker = $this->parse_ticker($data);
        $symbol = $ticker['symbol'];
        $this->tickers[$symbol] = $ticker;
        $messageHash = 'ticker:' . $symbol;
        $client->resolve ($ticker, $messageHash);
        return $message;
    }

    public function watch_order_book(string $symbol, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             *
             * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
             *
             * @param {string} $symbol unified $symbol of the $market to fetch the order book for
             * @param {int} [$limit] the maximum amount of order book entries to return
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->grouping] $orderbook $grouping level, '0', '1', '2', '3' (default '0')
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by $market symbols
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $url = $this->get_url(false, true, $market); // Use $orderbook URL
            $options = $this->safe_value($this->options, 'watchOrderBook', array());
            $grouping = $this->safe_string_2($params, 'grouping', 'group', $this->safe_string($options, 'grouping', '0'));
            $type = $this->safe_string($options, 'type', 'snapshotL2');
            $messageHash = 'orderbook:' . $symbol;
            $topic = $type . ':' . $market['id'] . '_' . $grouping;
            $request = array(
                'op' => 'subscribe',
                'args' => array( $topic ),
            );
            $orderbook = Async\await($this->watch($url, $messageHash, $request, $messageHash));
            return $orderbook->limit ();
        }) ();
    }

    public function watch_order_book_for_symbols(array $symbols, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $limit, $params) {
            /**
             * watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             *
             * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
             *
             * @param {string[]} $symbols unified array of $symbols
             * @param {int} [$limit] the maximum amount of order book entries to return
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->grouping] $orderbook $grouping level, '0', '1', '2', '3' (default '0')
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by $market $symbols
             */
            Async\await($this->load_markets());
            $firstMarket = $this->market($symbols[0]);
            $url = $this->get_url(false, true, $firstMarket);
            $options = $this->safe_value($this->options, 'watchOrderBook', array());
            $grouping = $this->safe_string_2($params, 'grouping', 'group', $this->safe_string($options, 'grouping', '0'));
            $type = $this->safe_string($options, 'type', 'snapshotL2');
            $messageHashes = array();
            $topics = array();
            for ($i = 0; $i < count($symbols); $i++) {
                $symbol = $symbols[$i];
                $market = $this->market($symbol);
                $topic = $type . ':' . $market['id'] . '_' . $grouping;
                $topics[] = $topic;
                $messageHashes[] = 'orderbook:' . $symbol;
            }
            $request = array(
                'op' => 'subscribe',
                'args' => $topics,
            );
            $orderbook = Async\await($this->watch_multiple($url, $messageHashes, $request, $messageHashes));
            return $orderbook->limit ();
        }) ();
    }

    public function un_watch_order_book(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * unwatch orderbook
             *
             * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
             *
             * @param {string} $symbol unified $symbol of the market to unwatch the orderbook for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {any} status
             */
            return Async\await($this->un_watch_order_book_for_symbols(array( $symbol ), $params));
        }) ();
    }

    public function un_watch_order_book_for_symbols(array $symbols, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * unwatch orderbook for $symbols
             *
             * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
             *
             * @param {string[]} $symbols unified $symbols of the markets to unwatch the orderbooks for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {any} status
             */
            Async\await($this->load_markets());
            $options = $this->safe_value($this->options, 'watchOrderBook', array());
            $grouping = $this->safe_string_2($params, 'grouping', 'group', $this->safe_string($options, 'grouping', '0'));
            $type = $this->safe_string($options, 'type', 'snapshotL2');
            $topics = array();
            $firstMarket = null;
            for ($i = 0; $i < count($symbols); $i++) {
                $symbol = $symbols[$i];
                $market = $this->market($symbol);
                if ($i === 0) {
                    $firstMarket = $market;
                }
                $topic = $type . ':' . $market['id'] . '_' . $grouping;
                $topics[] = $topic;
            }
            $url = $this->get_url(false, true, $firstMarket);
            $request = array(
                'op' => 'unsubscribe',
                'args' => $topics,
            );
            return Async\await($this->watch($url, 'unsubscribe:orderbook', $request, 'unsubscribe:orderbook'));
        }) ();
    }

    public function handle_order_book(Client $client, mixed $message): mixed {
        //
        // Snapshot:
        // {
        //   "topic" => "snapshotL2:BTC-PERP_0",
        //   "data" => {
        //     "bids" => [["28064.5", "1250"], ["28064.0", "850"]],
        //     "asks" => [["28065.0", "1015"], ["28065.5", "720"]],
        //     "type" => "snapshot",
        //     "symbol" => "BTC-PERP",
        //     "timestamp" => 1680751558529,
        //     "prevSeqNum" => 0,
        //     "seqNum" => 12345
        //   }
        // }
        //
        // Delta:
        // {
        //   "topic" => "snapshotL2:BTC-PERP_0",
        //   "data" => {
        //     "bids" => [["28064.5", "1300"]],
        //     "asks" => array(),
        //     "type" => "delta",
        //     "symbol" => "BTC-PERP",
        //     "timestamp" => 1680751559000,
        //     "prevSeqNum" => 12345,
        //     "seqNum" => 12346
        //   }
        // }
        //
        $data = $this->safe_dict($message, 'data', array());
        $marketId = $this->safe_string($data, 'symbol');
        $market = $this->safe_market($marketId);
        $symbol = $market['symbol'];
        $type = $this->safe_string($data, 'type');
        $timestamp = $this->safe_integer($data, 'timestamp');
        $seqNum = $this->safe_integer($data, 'seqNum');
        if ($type === 'snapshot') {
            $snapshot = $this->parse_order_book($data, $symbol, $timestamp);
            $snapshot['nonce'] = $seqNum;
            $orderbook = $this->safe_value($this->orderbooks, $symbol);
            if ($orderbook === null) {
                $orderbook = $this->order_book($snapshot);
            } else {
                $orderbook->reset ($snapshot);
            }
            $this->orderbooks[$symbol] = $orderbook;
        } elseif ($type === 'delta') {
            $orderbook = $this->safe_value($this->orderbooks, $symbol);
            if ($orderbook === null) {
                // Wait for $snapshot
                return $message;
            }
            $bids = $this->safe_list($data, 'bids', array());
            $asks = $this->safe_list($data, 'asks', array());
            $this->handle_deltas($orderbook['bids'], $bids);
            $this->handle_deltas($orderbook['asks'], $asks);
            $orderbook['nonce'] = $seqNum;
            $orderbook['timestamp'] = $timestamp;
            $orderbook['datetime'] = $this->iso8601($timestamp);
            $this->orderbooks[$symbol] = $orderbook;
        }
        $messageHash = 'orderbook:' . $symbol;
        $client->resolve ($this->orderbooks[$symbol], $messageHash);
        return $message;
    }

    public function handle_deltas($bookSide, $deltas) {
        for ($i = 0; $i < count($deltas); $i++) {
            $delta = $deltas[$i];
            $price = $this->safe_float($delta, 0);
            $amount = $this->safe_float($delta, 1);
            $bookSide->store ($price, $amount);
        }
    }

    public function watch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * get the list of most recent $trades for a particular $symbol
             *
             * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
             *
             * @param {string} $symbol unified $symbol of the $market to fetch $trades for
             * @param {int} [$since] timestamp in ms of the earliest trade to fetch
             * @param {int} [$limit] the maximum amount of $trades to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=public-$trades trade structures~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $url = $this->get_url(false, false, $market);
            $messageHash = 'trades:' . $symbol;
            // SPOT uses 'tradeHistoryApi:', FUTURES uses 'tradeHistoryApiV3:'
            $topicPrefix = $market['spot'] ? 'tradeHistoryApi:' : 'tradeHistoryApiV3:';
            $topic = $topicPrefix . $market['id'];
            $request = array(
                'op' => 'subscribe',
                'args' => array( $topic ),
            );
            $trades = Async\await($this->watch($url, $messageHash, $request, $messageHash));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp', true);
        }) ();
    }

    public function watch_trades_for_symbols(array $symbols, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $since, $limit, $params) {
            /**
             * get the list of most recent $trades for a particular $symbol
             *
             * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
             *
             * @param {string[]} $symbols unified $symbols of the markets to fetch $trades for
             * @param {int} [$since] timestamp in ms of the earliest trade to fetch
             * @param {int} [$limit] the maximum amount of $trades to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=public-$trades trade structures~
             */
            Async\await($this->load_markets());
            $messageHashes = array();
            $topics = array();
            $firstMarket = null;
            for ($i = 0; $i < count($symbols); $i++) {
                $symbol = $symbols[$i];
                $market = $this->market($symbol);
                if ($i === 0) {
                    $firstMarket = $market;
                }
                // SPOT uses 'tradeHistoryApi:', FUTURES uses 'tradeHistoryApiV3:'
                $topicPrefix = $market['spot'] ? 'tradeHistoryApi:' : 'tradeHistoryApiV3:';
                $topic = $topicPrefix . $market['id'];
                $topics[] = $topic;
                $messageHashes[] = 'trades:' . $symbol;
            }
            $url = $this->get_url(false, false, $firstMarket);
            $request = array(
                'op' => 'subscribe',
                'args' => $topics,
            );
            $trades = Async\await($this->watch_multiple($url, $messageHashes, $request, $messageHashes));
            if ($this->newUpdates) {
                if ($trades !== null) {
                    $first = $this->safe_value($trades, 0);
                    $symbol = $this->safe_string($first, 'symbol');
                    $limit = $trades->getLimit ($symbol, $limit);
                }
            }
            if ($trades === null) {
                return array();
            }
            return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp', true);
        }) ();
    }

    public function un_watch_trades(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * unwatch trades
             *
             * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
             *
             * @param {string} $symbol unified $symbol of the market to unwatch trades for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {any} status
             */
            return Async\await($this->un_watch_trades_for_symbols(array( $symbol ), $params));
        }) ();
    }

    public function un_watch_trades_for_symbols(array $symbols, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * unwatch trades for $symbols
             *
             * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
             *
             * @param {string[]} $symbols unified $symbols of the markets to unwatch trades for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {any} status
             */
            Async\await($this->load_markets());
            $topics = array();
            $firstMarket = null;
            for ($i = 0; $i < count($symbols); $i++) {
                $symbol = $symbols[$i];
                $market = $this->market($symbol);
                if ($i === 0) {
                    $firstMarket = $market;
                }
                // SPOT uses 'tradeHistoryApi:', FUTURES uses 'tradeHistoryApiV3:'
                $topicPrefix = $market['spot'] ? 'tradeHistoryApi:' : 'tradeHistoryApiV3:';
                $topic = $topicPrefix . $market['id'];
                $topics[] = $topic;
            }
            $url = $this->get_url(false, false, $firstMarket);
            $request = array(
                'op' => 'unsubscribe',
                'args' => $topics,
            );
            return Async\await($this->watch($url, 'unsubscribe:trades', $request, 'unsubscribe:trades'));
        }) ();
    }

    public function handle_trades(Client $client, mixed $message): mixed {
        //
        // {
        //   "topic" => "trades",
        //   "data" => [array(
        //     "symbol" => "BTCPFC",  // Note => BTSE uses different symbols in WS vs REST
        //     "side" => "BUY",
        //     "size" => "0.5",
        //     "price" => "28065.0",
        //     "tradeId" => "abc123def",
        //     "timestamp" => 1680751558529
        //   )]
        // }
        //
        $data = $this->safe_list($message, 'data', array());
        // BTSE sends "BTCPFC" for BTC-PERP in WebSocket messages
        // We need to find the correct $market by looking at what we have in our markets
        $tradesArray = array();
        $symbolsByMarketId = array();
        for ($i = 0; $i < count($data); $i++) {
            $rawData = $data[$i];
            $marketId = $this->safe_string($rawData, 'symbol'); // e.g., "BTCPFC"
            // BTSE uses different symbols in WebSocket (BTCPFC) vs REST API (BTC-PERP)
            // We need to map the WS $symbol to the correct $market
            $market = null;
            if ($marketId !== null && str_ends_with($marketId, 'PFC')) {
                // For perpetual futures, remove "PFC" suffix and add "-PERP"
                $baseSymbol = str_replace('PFC', '', $marketId);
                $perpId = $baseSymbol . '-PERP';
                $market = $this->safe_market($perpId, null, null, 'swap');
            } elseif ($marketId !== null) {
                // For other symbols, try direct lookup
                $market = $this->safe_market($marketId, null, null, 'swap');
            }
            $trade = $this->parse_trade($rawData, $market);
            $tradesArray[] = $trade;
            if ($trade['symbol'] !== null) {
                $symbolsByMarketId[$marketId] = $trade['symbol'];
            }
        }
        $first = $this->safe_value($tradesArray, 0, array());
        $symbol = $this->safe_string($first, 'symbol');
        if ($symbol === null) {
            return $message;
        }
        $stored = $this->safe_value($this->trades, $symbol);
        if ($stored === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $stored = new ArrayCacheBySymbolById ($limit);
            $this->trades[$symbol] = $stored;
        }
        // BTSE sends trades in descending order (newest $first)
        // Reverse to ascending order (oldest $first) by CCXT
        array_reverse($tradesArray);
        for ($i = 0; $i < count($tradesArray); $i++) {
            $stored->append ($tradesArray[$i]);
        }
        $messageHash = 'trades:' . $symbol;
        $client->resolve ($stored, $messageHash);
        return $message;
    }

    public function watch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * watches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
             *
             * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
             *
             * @param {string} $symbol unified $symbol of the $market to fetch OHLCV data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {int} [$since] timestamp in ms of the earliest candle to fetch
             * @param {int} [$limit] the maximum amount of candles to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {int[][]} A list of candles ordered, open, high, low, close, volume
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $url = $this->get_url(false, false, $market);
            $messageHash = 'ohlcv:' . $symbol . ':' . $timeframe;
            $topic = 'kline:' . $market['id'] . '_' . $timeframe;
            $request = array(
                'op' => 'subscribe',
                'args' => array( $topic ),
            );
            $ohlcv = Async\await($this->watch($url, $messageHash, $request, $messageHash));
            if ($this->newUpdates) {
                $limit = $ohlcv->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($ohlcv, $since, $limit, 0, true);
        }) ();
    }

    public function watch_ohlcv_for_symbols(array $symbolsAndTimeframes, ?int $since = null, ?int $limit = null, $params = array ()): array {
        return Async\async(function () use ($symbolsAndTimeframes, $since, $limit, $params) {
            /**
             * watches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
             *
             * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
             *
             * @param {string[][]} $symbolsAndTimeframes array of arrays containing unified symbols and timeframes to fetch OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
             * @param {int} [$since] timestamp in ms of the earliest candle to fetch
             * @param {int} [$limit] the maximum amount of candles to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {int[][]} A list of candles ordered, open, high, low, close, volume
             */
            Async\await($this->load_markets());
            $messageHashes = array();
            $topics = array();
            $firstMarket = null;
            for ($i = 0; $i < count($symbolsAndTimeframes); $i++) {
                $symbolAndTimeframe = $symbolsAndTimeframes[$i];
                $symbol = $symbolAndTimeframe[0];
                $timeframe = $symbolAndTimeframe[1];
                $market = $this->market($symbol);
                if ($i === 0) {
                    $firstMarket = $market;
                }
                $topic = 'kline:' . $market['id'] . '_' . $timeframe;
                $topics[] = $topic;
                $messageHashes[] = 'ohlcv:' . $symbol . ':' . $timeframe;
            }
            $url = $this->get_url(false, false, $firstMarket);
            $request = array(
                'op' => 'subscribe',
                'args' => $topics,
            );
            $ohlcv = Async\await($this->watch_multiple($url, $messageHashes, $request, $messageHashes));
            if ($this->newUpdates) {
                return $ohlcv;
            }
            return $this->filter_by_since_limit($ohlcv, $since, $limit, 0, true);
        }) ();
    }

    public function un_watch_ohlcv(string $symbol, $timeframe = '1m', $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $timeframe, $params) {
            /**
             * unwatch OHLCV
             *
             * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
             *
             * @param {string} $symbol unified $symbol of the market to unwatch OHLCV for
             * @param {string} $timeframe the length of time each candle represents
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {any} status
             */
            return Async\await($this->un_watch_ohlcv_for_symbols(array( array( $symbol, $timeframe ) ), $params));
        }) ();
    }

    public function un_watch_ohlcv_for_symbols(array $symbolsAndTimeframes, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbolsAndTimeframes, $params) {
            /**
             * unwatch OHLCV for symbols
             *
             * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
             *
             * @param {string[][]} $symbolsAndTimeframes array of arrays containing unified symbols and timeframes
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {any} status
             */
            Async\await($this->load_markets());
            $topics = array();
            $firstMarket = null;
            for ($i = 0; $i < count($symbolsAndTimeframes); $i++) {
                $symbolAndTimeframe = $symbolsAndTimeframes[$i];
                $symbol = $symbolAndTimeframe[0];
                $timeframe = $symbolAndTimeframe[1];
                $market = $this->market($symbol);
                if ($i === 0) {
                    $firstMarket = $market;
                }
                $topic = 'kline:' . $market['id'] . '_' . $timeframe;
                $topics[] = $topic;
            }
            $url = $this->get_url(false, false, $firstMarket);
            $request = array(
                'op' => 'unsubscribe',
                'args' => $topics,
            );
            return Async\await($this->watch($url, 'unsubscribe:ohlcv', $request, 'unsubscribe:ohlcv'));
        }) ();
    }

    public function handle_ohlcv(Client $client, mixed $message): mixed {
        //
        // {
        //   "topic" => "kline:BTC-PERP_1m",
        //   "data" => {
        //     "symbol" => "BTC-PERP",
        //     "interval" => "1m",
        //     "openTime" => 1680751500000,
        //     "closeTime" => 1680751559999,
        //     "open" => "28050.0",
        //     "high" => "28070.0",
        //     "low" => "28045.0",
        //     "close" => "28065.0",
        //     "volume" => "125.5",
        //     "timestamp" => 1680751559999
        //   }
        // }
        //
        $data = $this->safe_dict($message, 'data', array());
        $marketId = $this->safe_string($data, 'symbol');
        $market = $this->safe_market($marketId);
        $symbol = $market['symbol'];
        $interval = $this->safe_string($data, 'interval');
        $timeframe = $this->find_timeframe($interval);
        $parsed = array(
            $this->safe_integer($data, 'timestamp'),
            $this->safe_float($data, 'open'),
            $this->safe_float($data, 'high'),
            $this->safe_float($data, 'low'),
            $this->safe_float($data, 'close'),
            $this->safe_float($data, 'volume'),
        );
        $messageHash = 'ohlcv:' . $symbol . ':' . $timeframe;
        $stored = $this->safe_value($this->ohlcvs, $symbol);
        if ($stored === null) {
            $stored = array();
            $this->ohlcvs[$symbol] = $stored;
        }
        $storedArray = $this->safe_value($stored, $timeframe);
        if ($storedArray === null) {
            $limit = $this->safe_integer($this->options, 'OHLCVLimit', 1000);
            $storedArray = new ArrayCacheByTimestamp ($limit);
            $stored[$timeframe] = $storedArray;
        }
        $storedArray->append ($parsed);
        $client->resolve ($storedArray, $messageHash);
        return $message;
    }

    public function watch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $orders made by the user
             *
             * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
             *
             * @param {string} [$symbol] unified market $symbol of the market $orders were made in
             * @param {int} [$since] the earliest time in ms to fetch $orders for
             * @param {int} [$limit] the maximum number of order structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            Async\await($this->load_markets());
            Async\await($this->authenticate());
            $url = $this->get_url(true);
            $messageHash = 'orders';
            $topic = 'orders';
            $request = array(
                'op' => 'subscribe',
                'args' => array( $topic ),
            );
            $orders = Async\await($this->watch($url, $messageHash, $request, $messageHash));
            if ($this->newUpdates) {
                $limit = $orders->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($orders, $symbol, $since, $limit, true);
        }) ();
    }

    public function un_watch_orders(?string $symbol = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * unwatch orders
             *
             * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
             *
             * @param {string} [$symbol] unified market $symbol
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {any} status
             */
            Async\await($this->load_markets());
            $url = $this->get_url(true);
            $topic = 'orders';
            $request = array(
                'op' => 'unsubscribe',
                'args' => array( $topic ),
            );
            return Async\await($this->watch($url, 'unsubscribe:orders', $request, 'unsubscribe:orders'));
        }) ();
    }

    public function handle_orders(Client $client, mixed $message): mixed {
        //
        // {
        //   "topic" => "orders",
        //   "data" => [array(
        //     "orderId" => "order123",
        //     "clientOrderId" => "client456",
        //     "symbol" => "BTC-PERP",
        //     "orderType" => "LIMIT",
        //     "side" => "BUY",
        //     "price" => "28000.0",
        //     "size" => "1.0",
        //     "filledSize" => "0.5",
        //     "avgFillPrice" => "28000.0",
        //     "status" => "PARTIAL_FILLED",
        //     "triggerPrice" => null,
        //     "timestamp" => 1680751558529
        //   )]
        // }
        //
        $data = $this->safe_list($message, 'data', array());
        $ordersArray = array();
        for ($i = 0; $i < count($data); $i++) {
            $order = $this->parse_order($data[$i]);
            $ordersArray[] = $order;
        }
        $stored = $this->orders;
        if ($stored === null) {
            $limit = $this->safe_integer($this->options, 'ordersLimit', 1000);
            $stored = new ArrayCacheBySymbolById ($limit);
            $this->orders = $stored;
        }
        for ($i = 0; $i < count($ordersArray); $i++) {
            $stored->append ($ordersArray[$i]);
        }
        $messageHash = 'orders';
        $client->resolve ($stored, $messageHash);
        return $message;
    }

    public function watch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $trades made by the user
             *
             * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
             *
             * @param {string} [$symbol] unified market $symbol of the market $trades were made in
             * @param {int} [$since] the earliest time in ms to fetch $trades for
             * @param {int} [$limit] the maximum number of trade structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=trade-structure trade structures~
             */
            Async\await($this->load_markets());
            Async\await($this->authenticate());
            $url = $this->get_url(true);
            $messageHash = 'myTrades';
            $topic = 'fills';
            $request = array(
                'op' => 'subscribe',
                'args' => array( $topic ),
            );
            $trades = Async\await($this->watch($url, $messageHash, $request, $messageHash));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($trades, $symbol, $since, $limit, true);
        }) ();
    }

    public function un_watch_my_trades(?string $symbol = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * unwatch my trades
             *
             * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
             *
             * @param {string} [$symbol] unified market $symbol
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {any} status
             */
            Async\await($this->load_markets());
            $url = $this->get_url(true);
            $topic = 'fills';
            $request = array(
                'op' => 'unsubscribe',
                'args' => array( $topic ),
            );
            return Async\await($this->watch($url, 'unsubscribe:myTrades', $request, 'unsubscribe:myTrades'));
        }) ();
    }

    public function handle_my_trades(Client $client, mixed $message): mixed {
        //
        // {
        //   "topic" => "fills",
        //   "data" => [array(
        //     "orderId" => "order123",
        //     "tradeId" => "trade789",
        //     "symbol" => "BTC-PERP",
        //     "side" => "BUY",
        //     "price" => "28000.0",
        //     "size" => "0.5",
        //     "fee" => "0.00005",
        //     "feeCurrency" => "BTC",
        //     "feeRate" => "0.0001",
        //     "maker" => false,
        //     "timestamp" => 1680751558529
        //   )]
        // }
        //
        $data = $this->safe_list($message, 'data', array());
        $tradesArray = array();
        for ($i = 0; $i < count($data); $i++) {
            $trade = $this->parse_order($data[$i]);
            $tradesArray[] = $trade;
        }
        $stored = $this->myTrades;
        if ($stored === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $stored = new ArrayCacheBySymbolById ($limit);
            $this->myTrades = $stored;
        }
        for ($i = 0; $i < count($tradesArray); $i++) {
            $stored->append ($tradesArray[$i]);
        }
        $messageHash = 'myTrades';
        $client->resolve ($stored, $messageHash);
        return $message;
    }

    public function watch_positions(?array $symbols = null, ?int $since = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $since, $params) {
            /**
             * watch all open $positions
             *
             * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
             *
             * @param {string[]|null} $symbols list of unified market $symbols
             * @param {int} [$since] the earliest time in ms to fetch $positions for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=position-structure position structures~
             */
            Async\await($this->load_markets());
            Async\await($this->authenticate());
            $symbols = $this->market_symbols($symbols, null, false);
            $url = $this->get_url(true);
            $messageHash = 'positionsV3';
            $topic = 'positionsV3';
            $options = $this->safe_value($this->options, 'watchPositions', array());
            $fetchPositionsSnapshot = $this->safe_bool($options, 'fetchPositionsSnapshot', true);
            $awaitPositionsSnapshot = $this->safe_bool($options, 'awaitPositionsSnapshot', true);
            if ($fetchPositionsSnapshot && $awaitPositionsSnapshot) {
                $snapshot = Async\await($this->fetch_positions($symbols));
                if ($this->positions === null) {
                    $this->positions = new ArrayCacheBySymbolById ();
                }
                for ($i = 0; $i < count($snapshot); $i++) {
                    $this->positions.append ($snapshot[$i]);
                }
            }
            $request = array(
                'op' => 'subscribe',
                'args' => array( $topic ),
            );
            $positions = Async\await($this->watch($url, $messageHash, $request, $messageHash));
            if ($this->newUpdates) {
                return $positions;
            }
            return $this->filter_by_symbols_since_limit($positions, $symbols, $since, null, true);
        }) ();
    }

    public function un_watch_positions(?array $symbols = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * unwatch positions
             *
             * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
             *
             * @param {string[]} [$symbols] list of unified market $symbols
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {any} status
             */
            Async\await($this->load_markets());
            $url = $this->get_url(true);
            $topic = 'positionsV3';
            $request = array(
                'op' => 'unsubscribe',
                'args' => array( $topic ),
            );
            return Async\await($this->watch($url, 'unsubscribe:positionsV3', $request, 'unsubscribe:positionsV3'));
        }) ();
    }

    public function handle_positions(Client $client, mixed $message): mixed {
        //
        // {
        //   "topic" => "positionsV3",
        //   "data" => [array(
        //     "marketName" => "QA-PERP-USDT",
        //     "entryPrice" => 1500,
        //     "markedPrice" => 1500,
        //     "liquidationPrice" => 0,
        //     "unrealizedProfitLoss" => 0,
        //     "totalContracts" => 666,
        //     "marginTypeName" => "FUTURES_MARGIN_CROSS",
        //     "currentLeverage" => 0.0999085912,
        //     "positionId" => "QA-PERP-USDT",
        //     "positionMode" => "ONE_WAY",
        //     "positionDirection" => "LONG",
        //     "contractSize" => 0.01,
        //     "totalValue" => 9990
        //   )]
        // }
        //
        $data = $this->safe_list($message, 'data', array());
        $positionsArray = array();
        for ($i = 0; $i < count($data); $i++) {
            $position = $this->parse_position($data[$i]);
            $positionsArray[] = $position;
        }
        if ($this->positions === null) {
            $this->positions = new ArrayCacheBySymbolById ();
        }
        for ($i = 0; $i < count($positionsArray); $i++) {
            $this->positions.append ($positionsArray[$i]);
        }
        $messageHash = 'positionsV3';
        $client->resolve ($this->positions, $messageHash);
        return $message;
    }

    public function watch_balance($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * watch balance and get the amount of funds available for trading or funds locked in orders
             *
             * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
             *
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=balance-structure balance structure~
             */
            Async\await($this->load_markets());
            Async\await($this->authenticate());
            $url = $this->get_url(true);
            $messageHash = 'balance';
            $topic = 'wallet';
            $request = array(
                'op' => 'subscribe',
                'args' => array( $topic ),
            );
            return Async\await($this->watch($url, $messageHash, $request, $messageHash));
        }) ();
    }

    public function un_watch_balance($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * unwatch balance
             *
             * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
             *
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {any} status
             */
            Async\await($this->load_markets());
            $url = $this->get_url(true);
            $topic = 'wallet';
            $request = array(
                'op' => 'unsubscribe',
                'args' => array( $topic ),
            );
            return Async\await($this->watch($url, 'unsubscribe:balance', $request, 'unsubscribe:balance'));
        }) ();
    }

    public function handle_balance(Client $client, mixed $message): mixed {
        //
        // {
        //   "topic" => "wallet",
        //   "data" => [array(
        //     "currency" => "USDT",
        //     "total" => "10000.0",
        //     "available" => "8500.0",
        //     "reserved" => "1500.0",
        //     "timestamp" => 1680751558529
        //   ), array(
        //     "currency" => "BTC",
        //     "total" => "0.5",
        //     "available" => "0.3",
        //     "reserved" => "0.2",
        //     "timestamp" => 1680751558529
        //   )]
        // }
        //
        $data = $this->safe_list($message, 'data', array());
        $this->balance['info'] = $message;
        for ($i = 0; $i < count($data); $i++) {
            $balance = $data[$i];
            $currencyId = $this->safe_string($balance, 'currency');
            $code = $this->safe_currency_code($currencyId);
            $account = $this->account();
            $account['free'] = $this->safe_string($balance, 'available');
            $account['used'] = $this->safe_string($balance, 'reserved');
            $account['total'] = $this->safe_string($balance, 'total');
            $this->balance[$code] = $account;
        }
        $this->balance = $this->safe_balance($this->balance);
        $messageHash = 'balance';
        $client->resolve ($this->balance, $messageHash);
        return $message;
    }
}

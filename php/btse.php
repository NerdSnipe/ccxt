<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\abstract\btse as Exchange;

class btse extends Exchange {

    public function nonce() {
        return $this->milliseconds();
    }

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'btse',
            'name' => 'BTSE',
            'countries' => array( 'KY' ),
            'rateLimit' => 67,
            'version' => 'v2.3',
            'certified' => false,
            'pro' => false,
            'has' => array(
                'CORS' => null,
                'spot' => true,
                'margin' => false,
                'swap' => true,
                'future' => true,
                'option' => false,
                'cancelAllOrders' => true,
                'cancelOrder' => true,
                'createOrder' => true,
                'editOrder' => true,
                'fetchBalance' => true,
                'fetchCurrencies' => false,
                'fetchMarkets' => true,
                'fetchMyTrades' => true,
                'fetchOHLCV' => true,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchPositions' => true,
                'fetchTicker' => true,
                'fetchTickers' => true,
                'fetchTrades' => true,
                'fetchTransfers' => false,
                'sandbox' => true,
                'setLeverage' => true,
                'setMarginMode' => false,
                'transfer' => true,
            ),
            'features' => array(
                'swap' => array(
                    'linear' => array(
                        'sandbox' => true,
                        'createOrder' => array(
                            'marginMode' => false,
                            'triggerPrice' => true,
                            'triggerPriceType' => null,
                            'triggerDirection' => false,
                            'stopLossPrice' => true,
                            'takeProfitPrice' => true,
                            'attachedStopLossTakeProfit' => null,
                            'timeInForce' => array(
                                'GTC' => true,
                                'IOC' => true,
                                'FOK' => true,
                                'PO' => true,
                                'GTD' => false,
                            ),
                            'postOnly' => true,
                            'reduceOnly' => true,
                            'hedged' => false,
                            'trailing' => false,
                            'iceberg' => false,
                            'leverage' => false,
                            'marketBuyRequiresPrice' => false,
                            'marketBuyByCost' => true,
                        ),
                        'createOrders' => array(
                            'max' => 1,
                        ),
                        'fetchMyTrades' => array(
                            'marginMode' => false,
                            'limit' => 500,
                            'daysBack' => null,
                            'untilDays' => null,
                            'symbolRequired' => false,
                        ),
                        'fetchOrder' => array(
                            'marginMode' => false,
                            'trigger' => false,
                            'trailing' => false,
                            'symbolRequired' => true,
                        ),
                        'fetchOpenOrders' => array(
                            'marginMode' => false,
                            'limit' => null,
                            'trigger' => false,
                            'trailing' => false,
                            'symbolRequired' => false,
                        ),
                        'fetchOrders' => null,
                        'fetchClosedOrders' => null,
                        'fetchOHLCV' => array(
                            'limit' => null,
                        ),
                    ),
                ),
            ),
            'timeframes' => array(
                '1m' => '1',
                '5m' => '5',
                '15m' => '15',
                '30m' => '30',
                '1h' => '60',
                '2h' => '120',
                '4h' => '240',
                '6h' => '360',
                '12h' => '720',
                '1d' => '1440',
                '3d' => '4320',
                '1w' => '10080',
            ),
            'urls' => array(
                'logo' => 'https://user-images.githubusercontent.com/1294454/104117773-c7b2f880-52f4-11eb-8f2c-c21a4c626a32.jpg',
                'test' => array(
                    'public' => 'https://testapi.btse.io/futures',
                    'private' => 'https://testapi.btse.io/futures',
                    'publicSpot' => 'https://testapi.btse.io/spot',
                    'privateSpot' => 'https://testapi.btse.io/spot',
                ),
                'api' => array(
                    'public' => 'https://api.btse.com/futures',
                    'private' => 'https://api.btse.com/futures',
                    'publicSpot' => 'https://api.btse.com/spot',
                    'privateSpot' => 'https://api.btse.com/spot',
                ),
                'www' => 'https://www.btse.com',
                'doc' => array(
                    'https://btsecom.github.io/docs/futuresV2_3/en/',
                    'https://btsecom.github.io/docs/spotV3_3/en/',
                ),
                'fees' => 'https://www.btse.com/en/fees',
            ),
            'api' => array(
                'public' => array(
                    'get' => array(
                        'api/v2.3/market_summary',
                        'api/v2.3/ohlcv',
                        'api/v2.3/price',
                        'api/v2.3/orderbook',
                        'api/v2.3/trades',
                    ),
                ),
                'publicSpot' => array(
                    'get' => array(
                        'api/v3.2/market_summary',
                        'api/v3.2/ohlcv',
                        'api/v3.2/price',
                        'api/v3.2/orderbook/L2',
                        'api/v3.2/trades',
                    ),
                ),
                'private' => array(
                    'get' => array(
                        'api/v2.3/user/wallet',
                        'api/v2.3/user/wallet_history',
                        'api/v2.3/user/open_orders',
                        'api/v2.3/user/positions',
                        'api/v2.3/user/trade_history',
                    ),
                    'post' => array(
                        'api/v2.3/order',
                        'api/v2.3/user/wallet/transfer',
                        'api/v2.3/leverage',
                        'api/v2.3/position_mode',
                    ),
                    'put' => array(
                        'api/v2.3/order',
                    ),
                    'delete' => array(
                        'api/v2.3/order',
                    ),
                ),
            ),
            'fees' => array(
                'trading' => array(
                    'tierBased' => true,
                    'percentage' => true,
                    'maker' => $this->parse_number('0.0006'),
                    'taker' => $this->parse_number('0.0010'),
                ),
            ),
            'exceptions' => array(
                'exact' => array(
                    'INVALID_SYMBOL' => '\\ccxt\\BadSymbol',
                    'SYMBOL_NOT_FOUND' => '\\ccxt\\BadSymbol',
                    'INSUFFICIENT_BALANCE' => '\\ccxt\\InsufficientFunds',
                    'INSUFFICIENT_MARGIN' => '\\ccxt\\InsufficientFunds',
                    'INVALID_ORDER_SIZE' => '\\ccxt\\InvalidOrder',
                    'INVALID_PRICE' => '\\ccxt\\InvalidOrder',
                    'ORDER_SIZE_TOO_SMALL' => '\\ccxt\\InvalidOrder',
                    'ORDER_SIZE_TOO_LARGE' => '\\ccxt\\InvalidOrder',
                    'PRICE_TOO_HIGH' => '\\ccxt\\InvalidOrder',
                    'PRICE_TOO_LOW' => '\\ccxt\\InvalidOrder',
                    'ORDER_NOT_FOUND' => '\\ccxt\\OrderNotFound',
                    'ORDER_ALREADY_FILLED' => '\\ccxt\\OrderNotFound',
                    'ORDER_ALREADY_CANCELLED' => '\\ccxt\\OrderNotFound',
                    'RATE_LIMIT_EXCEEDED' => '\\ccxt\\RateLimitExceeded',
                    'TOO_MANY_REQUESTS' => '\\ccxt\\RateLimitExceeded',
                    'INVALID_API_KEY' => '\\ccxt\\AuthenticationError',
                    'INVALID_SIGNATURE' => '\\ccxt\\AuthenticationError',
                    'API_KEY_EXPIRED' => '\\ccxt\\AuthenticationError',
                    'PERMISSION_DENIED' => '\\ccxt\\PermissionDenied',
                    'IP_RESTRICTED' => '\\ccxt\\PermissionDenied',
                    'MARKET_CLOSED' => '\\ccxt\\InvalidOrder',
                    'MAINTENANCE_MODE' => '\\ccxt\\ExchangeNotAvailable',
                    'INVALID_NONCE' => '\\ccxt\\InvalidNonce',
                    'DUPLICATE_ORDER_ID' => '\\ccxt\\DuplicateOrderId',
                ),
                'broad' => array(
                    'rate limit' => '\\ccxt\\RateLimitExceeded',
                    'too many' => '\\ccxt\\RateLimitExceeded',
                    'insufficient' => '\\ccxt\\InsufficientFunds',
                    'invalid' => '\\ccxt\\InvalidOrder',
                    'not found' => '\\ccxt\\OrderNotFound',
                    'permission' => '\\ccxt\\PermissionDenied',
                    'authentication' => '\\ccxt\\AuthenticationError',
                    'signature' => '\\ccxt\\AuthenticationError',
                    'maintenance' => '\\ccxt\\ExchangeNotAvailable',
                ),
            ),
            'precisionMode' => TICK_SIZE,
            'options' => array(
                'sandboxMode' => false,
            ),
        ));
    }

    public function after_construct() {
        parent::after_construct();
        $whitelabelDomain = $this->safe_string($this->options, 'whitelabel_domain');
        if ($whitelabelDomain !== null) {
            $testPublic = 'https://testapi.' . $whitelabelDomain . '/futures';
            $testPrivate = 'https://testapi.' . $whitelabelDomain . '/futures';
            $apiPublic = 'https://api.' . $whitelabelDomain . '/futures';
            $apiPrivate = 'https://api.' . $whitelabelDomain . '/futures';
            $this->urls['test'] = array(
                'public' => $testPublic,
                'private' => $testPrivate,
            );
            $this->urls['api'] = array(
                'public' => $apiPublic,
                'private' => $apiPrivate,
            );
        }
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $request = '/' . $this->implode_params($path, $params);
        $url = $this->urls['api'][$api] . $request;
        $query = $this->omit($params, $this->extract_params($path));
        $isPublic = ($api === 'public') || ($api === 'publicSpot');
        if ($isPublic) {
            if ($query) {
                $url .= '?' . $this->urlencode($query);
            }
        } else {
            $this->check_required_credentials();
            $nonce = (string) $this->nonce();
            $bodyStr = '';
            if ($method === 'POST' || $method === 'PUT') {
                if ($query) {
                    $body = $this->json($query);
                    $bodyStr = $body;
                }
            } elseif ($query) {
                // Add $query parameters to URL only, NOT to $signature
                $url .= '?' . $this->urlencode($query);
            }
            // Signature => $path . $nonce . $body ($query $params NOT included in $signature)
            $auth = $request . $nonce . $bodyStr;
            $signature = $this->hmac($this->encode($auth), $this->encode($this->secret), 'sha384', 'hex');
            $headers = array(
                'request-api' => $this->apiKey,
                'request-nonce' => $nonce,
                'request-sign' => $signature,
                'Content-Type' => 'application/json',
            );
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function handle_errors(int $code, string $reason, string $url, string $method, array $headers, string $body, $response, $requestHeaders, $requestBody) {
        if ($response === null) {
            return null;
        }
        $errorCode = $this->safe_string($response, 'errorCode');
        $message = $this->safe_string($response, 'message', '');
        if ($errorCode !== null) {
            $feedback = $this->id . ' ' . $body;
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $errorCode, $feedback);
            $this->throw_broadly_matched_exception($this->exceptions['broad'], $message, $feedback);
            throw new ExchangeError($feedback);
        }
        return null;
    }

    public function fetch_markets($params = array ()): array {
        /**
         * retrieves data on all markets for btse
         *
         * @see https://btsecom.github.io/docs/futuresV2_3/en/#$market-summary
         * @see https://btsecom.github.io/docs/spotV3_3/en/#$market-summary
         *
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array[]} an array of objects representing $market data
         */
        // Fetch both SPOT and FUTURES markets
        $promises = array(
            $this->publicGetApiV23MarketSummary ($params), // FUTURES
            $this->publicSpotGetApiV32MarketSummary ($params), // SPOT
        );
        $responses = $promises;
        $futuresResponse = $responses[0];
        $spotResponse = $responses[1];
        $result = array();
        // Parse FUTURES markets
        for ($i = 0; $i < count($futuresResponse); $i++) {
            $market = $futuresResponse[$i];
            $parsed = $this->parse_market($market);
            $result[] = $parsed;
        }
        // Parse SPOT markets
        for ($i = 0; $i < count($spotResponse); $i++) {
            $market = $spotResponse[$i];
            $parsed = $this->parse_market($market);
            $result[] = $parsed;
        }
        return $result;
    }

    public function parse_market($market): array {
        $id = $this->safe_string($market, 'symbol');
        $baseId = $this->safe_string($market, 'base');
        $quoteId = $this->safe_string($market, 'quote');
        $base = $this->safe_currency_code($baseId);
        $quote = $this->safe_currency_code($quoteId);
        $active = $this->safe_bool($market, 'active', true);
        $minPriceIncrement = $this->safe_string($market, 'minPriceIncrement');
        $minSizeIncrement = $this->safe_string($market, 'minSizeIncrement');
        $minOrderSize = $this->safe_string($market, 'minOrderSize');
        $maxOrderSize = $this->safe_string($market, 'maxOrderSize');
        $contractSize = $this->safe_string($market, 'contractSize', '1');
        // Detect $market $type from data
        $futures = $this->safe_bool($market, 'futures', false);
        $type = $futures ? 'swap' : 'spot';
        $spot = ($type === 'spot');
        $swap = ($type === 'swap');
        $symbol = null;
        $settle = null;
        $settleId = null;
        if ($spot) {
            // SPOT => BTC/USDT
            $symbol = $base . '/' . $quote;
            $settle = null;
            $settleId = null;
        } else {
            // FUTURES => BTC/USDT:USDT
            $symbol = $base . '/' . $quote . ':' . $quote;
            $settle = $quote;
            $settleId = $quoteId;
        }
        return array(
            'id' => $id,
            'symbol' => $symbol,
            'base' => $base,
            'quote' => $quote,
            'settle' => $settle,
            'baseId' => $baseId,
            'quoteId' => $quoteId,
            'settleId' => $settleId,
            'type' => $type,
            'spot' => $spot,
            'margin' => false,
            'swap' => $swap,
            'future' => false,
            'option' => false,
            'active' => $active,
            'contract' => $swap,
            'linear' => $swap ? true : null,
            'inverse' => $swap ? false : null,
            'contractSize' => $swap ? $this->parse_number($contractSize) : null,
            'expiry' => null,
            'expiryDatetime' => null,
            'strike' => null,
            'optionType' => null,
            'precision' => array(
                'amount' => $this->parse_number($minSizeIncrement),
                'price' => $this->parse_number($minPriceIncrement),
            ),
            'limits' => array(
                'leverage' => array(
                    'min' => null,
                    'max' => null,
                ),
                'amount' => array(
                    'min' => $this->parse_number($minOrderSize),
                    'max' => $this->parse_number($maxOrderSize),
                ),
                'price' => array(
                    'min' => $this->parse_number($minPriceIncrement),
                    'max' => null,
                ),
                'cost' => array(
                    'min' => null,
                    'max' => null,
                ),
            ),
            'created' => null,
            'info' => $market,
        );
    }

    public function fetch_ticker(string $symbol, $params = array ()) {
        /**
         * fetches a price $ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
         *
         * @see https://btsecom.github.io/docs/futuresV2_3/en/#$market-summary
         *
         * @param {string} $symbol unified $symbol of the $market to fetch the $ticker for
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a ~@link https://docs.ccxt.com/#/?id=$ticker-structure $ticker structure~
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        $response = null;
        if ($market['spot']) {
            $response = $this->publicSpotGetApiV32MarketSummary ($this->extend($request, $params));
        } else {
            $response = $this->publicGetApiV23MarketSummary ($this->extend($request, $params));
        }
        $ticker = $this->safe_dict($response, 0);
        return $this->parse_ticker($ticker, $market);
    }

    public function parse_ticker($ticker, ?array $market = null) {
        $marketId = $this->safe_string($ticker, 'symbol');
        $symbol = $this->safe_symbol($marketId, $market);
        $last = $this->safe_string($ticker, 'last');
        $percentage = $this->safe_string($ticker, 'percentageChange');
        $baseVolume = $this->safe_string($ticker, 'volume');
        $high = $this->safe_string($ticker, 'high24Hr');
        $low = $this->safe_string($ticker, 'low24Hr');
        $bid = $this->safe_string($ticker, 'highestBid');
        $ask = $this->safe_string($ticker, 'lowestAsk');
        $size = $this->safe_string($ticker, 'size');
        return $this->safe_ticker(array(
            'symbol' => $symbol,
            'timestamp' => null,
            'datetime' => null,
            'high' => $high,
            'low' => $low,
            'bid' => $bid,
            'bidVolume' => null,
            'ask' => $ask,
            'askVolume' => null,
            'vwap' => null,
            'open' => null,
            'close' => $last,
            'last' => $last,
            'previousClose' => null,
            'change' => null,
            'percentage' => $percentage,
            'average' => null,
            'baseVolume' => $baseVolume,
            'quoteVolume' => $size,
            'info' => $ticker,
        ), $market);
    }

    public function fetch_order_book(string $symbol, ?int $limit = null, $params = array ()) {
        /**
         * fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
         *
         * @see https://btsecom.github.io/docs/futuresV2_3/en/#orderbook
         *
         * @param {string} $symbol unified $symbol of the $market to fetch the order book for
         * @param {int} [$limit] the maximum amount of order book entries to return
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {int} [$params->group] orderbook grouping level (0-8)
         * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by $market symbols
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        $response = null;
        if ($market['spot']) {
            $response = $this->publicSpotGetApiV32OrderbookL2 ($this->extend($request, $params));
        } else {
            $response = $this->publicGetApiV23Orderbook ($this->extend($request, $params));
        }
        $timestamp = $this->safe_integer($response, 'timestamp');
        return $this->parse_order_book($response, $symbol, $timestamp, 'buyQuote', 'sellQuote', 'price', 'size');
    }

    public function fetch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()) {
        /**
         * get the list of most recent trades for a particular $symbol
         *
         * @see https://btsecom.github.io/docs/futuresV2_3/en/#trades
         *
         * @param {string} $symbol unified $symbol of the $market to fetch trades for
         * @param {int} [$since] timestamp in ms of the earliest trade to fetch
         * @param {int} [$limit] the maximum amount of trades to fetch
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {int} [$params->until] timestamp in ms of the latest trade to fetch
         * @return {Trade[]} a list of ~@link https://docs.ccxt.com/#/?id=public-trades trade structures~
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
            'count' => $limit !== null ? $limit : 100,
        );
        if ($since !== null) {
            $request['startTime'] = $since;
        }
        $until = $this->safe_integer($params, 'until');
        if ($until !== null) {
            $params = $this->omit($params, 'until');
            $request['endTime'] = $until;
        }
        $response = null;
        if ($market['spot']) {
            $response = $this->publicSpotGetApiV32Trades ($this->extend($request, $params));
        } else {
            $response = $this->publicGetApiV23Trades ($this->extend($request, $params));
        }
        return $this->parse_trades($response, $market, $since, $limit);
    }

    public function parse_trade($trade, ?array $market = null) {
        $marketId = $this->safe_string($trade, 'symbol');
        $symbol = $this->safe_symbol($marketId, $market);
        $timestamp = $this->safe_integer($trade, 'timestamp');
        $side = $this->safe_string_lower($trade, 'side');
        $priceString = $this->safe_string_2($trade, 'filledPrice', 'price');
        $amountString = $this->safe_string_2($trade, 'filledSize', 'size');
        $id = $this->safe_string_2($trade, 'tradeId', 'serialId');
        $orderId = $this->safe_string($trade, 'orderId');
        $feeAmount = $this->safe_string($trade, 'feeAmount');
        $feeCurrency = $this->safe_string($trade, 'feeCurrency');
        $fee = ($feeAmount !== null) ? {
            'cost' => $feeAmount,
            'currency' => $this->safe_currency_code($feeCurrency),
        } : null;
        $costString = $this->safe_string($trade, 'total');
        return $this->safe_trade(array(
            'id' => $id,
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'type' => null,
            'side' => $side,
            'order' => $orderId,
            'takerOrMaker' => null,
            'price' => $priceString,
            'amount' => $amountString,
            'cost' => $costString,
            'fee' => $fee,
        ), $market);
    }

    public function fetch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()) {
        /**
         * fetches historical candlestick data containing the open, high, low, close price, and the volume of a $market
         *
         * @see https://btsecom.github.io/docs/futuresV2_3/en/#ohlcv
         *
         * @param {string} $symbol unified $symbol of the $market to fetch OHLCV data for
         * @param {string} $timeframe the length of time each candle represents
         * @param {int} [$since] timestamp in ms of the earliest candle to fetch
         * @param {int} [$limit] the maximum amount of candles to fetch
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {int} [$params->until] timestamp in ms of the latest candle to fetch
         * @return {int[][]} A list of candles ordered, open, high, low, close, volume
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
            'resolution' => $this->safe_string($this->timeframes, $timeframe, $timeframe),
        );
        if ($since !== null) {
            $request['start'] = $since;
        }
        $until = $this->safe_integer($params, 'until');
        if ($until !== null) {
            $params = $this->omit($params, 'until');
            $request['end'] = $until;
        }
        $response = null;
        if ($market['spot']) {
            $response = $this->publicSpotGetApiV32Ohlcv ($this->extend($request, $params));
        } else {
            $response = $this->publicGetApiV23Ohlcv ($this->extend($request, $params));
        }
        return $this->parse_ohlcvs($response, $market, $timeframe, $since, $limit);
    }

    public function fetch_balance($params = array ()): array {
        /**
         * query for balance and get the amount of funds available for trading or funds locked in orders
         *
         * @see https://btsecom.github.io/docs/futuresV2_3/en/#$wallet
         *
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} [$params->wallet] $wallet name, defaults to 'CROSS@'
         * @return {array} a ~@link https://docs.ccxt.com/#/?id=balance-structure balance structure~
         */
        $this->load_markets();
        $wallet = $this->safe_string($params, 'wallet', 'CROSS@');
        $request = array(
            'wallet' => $wallet,
        );
        $response = $this->privateGetApiV23UserWallet ($this->extend($request, $params));
        return $this->parse_balance($response);
    }

    public function parse_balance($response): array {
        $result = array(
            'info' => $response,
        );
        $wallets = $this->safe_list($response, 0, array());
        if (strlen($wallets) === 0) {
            return $this->safe_balance($result);
        }
        $wallet = $this->safe_dict($response, 0);
        $assets = $this->safe_list($wallet, 'assets', array());
        for ($i = 0; $i < count($assets); $i++) {
            $asset = $assets[$i];
            $currencyId = $this->safe_string($asset, 'currency');
            $code = $this->safe_currency_code($currencyId);
            $account = $this->account();
            $account['total'] = $this->safe_string($asset, 'balance');
            $result[$code] = $account;
        }
        $availableBalance = $this->safe_string($wallet, 'availableBalance');
        $marginBalance = $this->safe_string($wallet, 'marginBalance');
        if ($availableBalance !== null || $marginBalance !== null) {
            $result['free'] = $availableBalance;
            $result['used'] = $marginBalance;
            $result['total'] = $this->safe_string($wallet, 'totalValue');
        }
        return $this->safe_balance($result);
    }

    public function create_order(string $symbol, string $type, string $side, float $amount, ?float $price = null, $params = array ()): array {
        /**
         * create a trade $order
         *
         * @see https://btsecom.github.io/docs/futuresV2_3/en/#$order
         *
         * @param {string} $symbol unified $symbol of the $market to create an $order in
         * @param {string} $type 'market' or 'limit'
         * @param {string} $side 'buy' or 'sell'
         * @param {float} $amount how much you want to trade in units of the base currency
         * @param {float} [$price] the $price at which the $order is to be fulfilled, in units of the quote currency, ignored in $market orders
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} [$params->timeInForce] 'GTC', 'IOC', 'FOK', or 'PO'
         * @param {bool} [$params->postOnly] true or false
         * @param {bool} [$params->reduceOnly] true or false
         * @param {float} [$params->triggerPrice] $price to trigger stop orders
         * @param {float} [$params->stopPrice] $price for OCO orders
         * @param {float} [$params->takeProfitPrice] take profit trigger $price
         * @param {float} [$params->stopLossPrice] stop loss trigger $price
         * @param {string} [$params->clOrderID] client $order ID
         * @return {array} an ~@link https://docs.ccxt.com/#/?id=$order-structure $order structure~
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $uppercaseType = strtoupper($type);
        $uppercaseSide = strtoupper($side);
        $request = array(
            'symbol' => $market['id'],
            'side' => $uppercaseSide,
            'type' => $uppercaseType,
            'size' => $this->amount_to_precision($symbol, $amount),
        );
        if ($uppercaseType === 'LIMIT') {
            if ($price === null) {
                throw new InvalidOrder($this->id . ' createOrder() requires a $price argument for limit orders');
            }
            $request['price'] = $this->price_to_precision($symbol, $price);
        }
        $timeInForce = $this->safe_string($params, 'timeInForce');
        if ($timeInForce !== null) {
            $request['time_in_force'] = $timeInForce;
        }
        $postOnly = $this->safe_bool($params, 'postOnly');
        if ($postOnly !== null) {
            $request['postOnly'] = $postOnly;
        }
        $reduceOnly = $this->safe_bool($params, 'reduceOnly');
        if ($reduceOnly !== null) {
            $request['reduceOnly'] = $reduceOnly;
        }
        $triggerPrice = $this->safe_string($params, 'triggerPrice');
        if ($triggerPrice !== null) {
            $request['triggerPrice'] = $this->price_to_precision($symbol, $triggerPrice);
        }
        $stopPrice = $this->safe_string($params, 'stopPrice');
        if ($stopPrice !== null) {
            $request['stopPrice'] = $this->price_to_precision($symbol, $stopPrice);
        }
        $takeProfitPrice = $this->safe_string($params, 'takeProfitPrice');
        if ($takeProfitPrice !== null) {
            $request['takeProfitPrice'] = $this->price_to_precision($symbol, $takeProfitPrice);
        }
        $stopLossPrice = $this->safe_string($params, 'stopLossPrice');
        if ($stopLossPrice !== null) {
            $request['stopLossPrice'] = $this->price_to_precision($symbol, $stopLossPrice);
        }
        $clientOrderId = $this->safe_string($params, 'clOrderID');
        if ($clientOrderId !== null) {
            $request['clOrderID'] = $clientOrderId;
        }
        $params = $this->omit($params, array( 'timeInForce', 'postOnly', 'reduceOnly', 'triggerPrice', 'stopPrice', 'takeProfitPrice', 'stopLossPrice', 'clOrderID' ));
        $response = $this->privatePostApiV23Order ($this->extend($request, $params));
        $order = gettype($response) === 'array' && array_keys($response) === array_keys(array_keys($response)) ? $response[0] : $response;
        return $this->parse_order($order, $market);
    }

    public function parse_order($order, ?array $market = null): array {
        $marketId = $this->safe_string($order, 'symbol');
        $symbol = $this->safe_symbol($marketId, $market);
        $orderId = $this->safe_string($order, 'orderID');
        $clientOrderId = $this->safe_string($order, 'clOrderID');
        $timestamp = $this->safe_integer($order, 'timestamp');
        $side = $this->safe_string_lower($order, 'side');
        $type = $this->safe_string_lower($order, 'type');
        $price = $this->safe_string($order, 'price');
        $amount = $this->safe_string($order, 'originalOrderSize');
        $filled = $this->safe_string($order, 'filledSize');
        $remaining = $this->safe_string($order, 'currentOrderSize');
        $status = $this->parse_order_status($this->safe_string($order, 'status'));
        $average = $this->safe_string($order, 'avgFillPrice');
        $timeInForce = $this->safe_string($order, 'timeInForce');
        $postOnly = $this->safe_bool($order, 'postOnly');
        $reduceOnly = $this->safe_bool($order, 'reduceOnly');
        $triggerPrice = $this->safe_string($order, 'triggerPrice');
        $stopPrice = $this->safe_string($order, 'stopPrice');
        return $this->safe_order(array(
            'id' => $orderId,
            'clientOrderId' => $clientOrderId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => null,
            'status' => $status,
            'symbol' => $symbol,
            'type' => $type,
            'timeInForce' => $timeInForce,
            'postOnly' => $postOnly,
            'reduceOnly' => $reduceOnly,
            'side' => $side,
            'price' => $price,
            'stopPrice' => $stopPrice,
            'triggerPrice' => $triggerPrice,
            'amount' => $amount,
            'filled' => $filled,
            'remaining' => $remaining,
            'cost' => null,
            'average' => $average,
            'trades' => null,
            'fee' => null,
            'info' => $order,
        ), $market);
    }

    public function parse_order_status($status) {
        $statuses = array(
            '1' => 'open',
            '2' => 'open',
            '4' => 'closed',
            '5' => 'canceled',
            '6' => 'open',
            '8' => 'canceled',
            '9' => 'canceled',
            '10' => 'canceled',
            '15' => 'rejected',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function cancel_order(string $id, ?string $symbol = null, $params = array ()): array {
        /**
         * cancels an open order
         *
         * @see https://btsecom.github.io/docs/futuresV2_3/en/#order-2
         *
         * @param {string} $id order $id
         * @param {string} $symbol unified $symbol of the $market the order was made in
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} [$params->clOrderID] client order $id
         * @return {array} An ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
         */
        if ($symbol === null) {
            throw new InvalidOrder($this->id . ' cancelOrder() requires a $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        $clientOrderId = $this->safe_string($params, 'clOrderID');
        if ($clientOrderId !== null) {
            $request['clOrderID'] = $clientOrderId;
            $params = $this->omit($params, 'clOrderID');
        } else {
            $request['orderID'] = $id;
        }
        $response = $this->privateDeleteApiV23Order ($this->extend($request, $params));
        return $this->parse_order($response, $market);
    }

    public function cancel_all_orders(?string $symbol = null, $params = array ()) {
        /**
         * cancel all open orders in a $market
         *
         * @see https://btsecom.github.io/docs/futuresV2_3/en/#order-2
         *
         * @param {string} $symbol unified $market $symbol
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
         */
        if ($symbol === null) {
            throw new InvalidOrder($this->id . ' cancelAllOrders() requires a $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        $response = $this->privateDeleteApiV23Order ($this->extend($request, $params));
        if (gettype($response) === 'array' && array_keys($response) === array_keys(array_keys($response))) {
            return $this->parse_orders($response, $market);
        }
        return array( $this->parse_order($response, $market) );
    }

    public function edit_order(string $id, string $symbol, string $type, string $side, ?float $amount = null, ?float $price = null, $params = array ()): array {
        /**
         * edit a trade order
         *
         * @see https://btsecom.github.io/docs/futuresV2_3/en/#order-1
         *
         * @param {string} $id order $id
         * @param {string} $symbol unified $symbol of the $market to edit the order in
         * @param {string} $type not used by btse editOrder
         * @param {string} $side not used by btse editOrder
         * @param {float} [$amount] how much you want to trade in units of the base currency
         * @param {float} [$price] the $price at which the order is to be fulfilled, in units of the quote currency
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {float} [$params->triggerPrice] $price to trigger stop orders
         * @param {string} [$params->clOrderID] client order $id
         * @return {array} an ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        $clientOrderId = $this->safe_string($params, 'clOrderID');
        if ($clientOrderId !== null) {
            $request['clOrderID'] = $clientOrderId;
            $params = $this->omit($params, 'clOrderID');
        } else {
            $request['orderID'] = $id;
        }
        $triggerPrice = $this->safe_string($params, 'triggerPrice');
        if ($price !== null && $amount !== null && $triggerPrice !== null) {
            $request['type'] = 'ALL';
            $request['orderPrice'] = $this->price_to_precision($symbol, $price);
            $request['orderSize'] = $this->amount_to_precision($symbol, $amount);
            $request['triggerPrice'] = $this->price_to_precision($symbol, $triggerPrice);
            $params = $this->omit($params, 'triggerPrice');
        } elseif ($price !== null && $amount !== null) {
            $request['type'] = 'ALL';
            $request['orderPrice'] = $this->price_to_precision($symbol, $price);
            $request['orderSize'] = $this->amount_to_precision($symbol, $amount);
        } elseif ($price !== null) {
            $request['type'] = 'PRICE';
            $request['value'] = $this->price_to_precision($symbol, $price);
        } elseif ($amount !== null) {
            $request['type'] = 'SIZE';
            $request['value'] = $this->amount_to_precision($symbol, $amount);
        } elseif ($triggerPrice !== null) {
            $request['type'] = 'TRIGGERPRICE';
            $request['value'] = $this->price_to_precision($symbol, $triggerPrice);
            $params = $this->omit($params, 'triggerPrice');
        } else {
            throw new InvalidOrder($this->id . ' editOrder() requires a $price, $amount, or $triggerPrice argument');
        }
        $response = $this->privatePutApiV23Order ($this->extend($request, $params));
        return $this->parse_order($response, $market);
    }

    public function fetch_open_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        /**
         * fetch all unfilled currently open orders
         *
         * @see https://btsecom.github.io/docs/futuresV2_3/en/#query-open-orders
         *
         * @param {string} $symbol unified $market $symbol
         * @param {int} [$since] not used by btse fetchOpenOrders
         * @param {int} [$limit] not used by btse fetchOpenOrders
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {Order[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
         */
        $this->load_markets();
        $market = null;
        $request = array();
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
        }
        $response = $this->privateGetApiV23UserOpenOrders ($this->extend($request, $params));
        return $this->parse_orders($response, $market, $since, $limit);
    }

    public function fetch_order(string $id, ?string $symbol = null, $params = array ()): array {
        /**
         * fetches information on an order made by the user
         *
         * @see https://btsecom.github.io/docs/futuresV2_3/en/#query-open-orders
         *
         * @param {string} $id order $id
         * @param {string} $symbol unified $symbol of the $market the order was made in
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} [$params->clOrderID] client order $id
         * @return {array} An ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
         */
        $this->load_markets();
        $request = array();
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
        }
        $clientOrderId = $this->safe_string($params, 'clOrderID');
        if ($clientOrderId !== null) {
            $request['clOrderID'] = $clientOrderId;
            $params = $this->omit($params, 'clOrderID');
        } else {
            $request['orderID'] = $id;
        }
        $response = $this->privateGetApiV23UserOpenOrders ($this->extend($request, $params));
        if (gettype($response) === 'array' && array_keys($response) === array_keys(array_keys($response)) && strlen($response) > 0) {
            return $this->parse_order($response[0], $market);
        }
        throw new OrderNotFound($this->id . ' fetchOrder() could not find order ' . $id);
    }

    public function fetch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        /**
         * fetch all trades made by the user
         *
         * @see https://btsecom.github.io/docs/futuresV2_3/en/#query-trades-fills
         *
         * @param {string} $symbol unified $market $symbol
         * @param {int} [$since] timestamp in ms of the earliest trade to fetch
         * @param {int} [$limit] the maximum number of trades to fetch
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {int} [$params->until] timestamp in ms of the latest trade to fetch
         * @param {string} [$params->orderID] filter trades by order ID
         * @param {string} [$params->clOrderID] filter trades by client order ID
         * @param {bool} [$params->includeOld] include trades older than 7 days
         * @return {Trade[]} a list of ~@link https://docs.ccxt.com/#/?id=trade-structure trade structures~
         */
        $this->load_markets();
        $market = null;
        $request = array();
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
        }
        if ($since !== null) {
            $request['startTime'] = $since;
        }
        $until = $this->safe_integer($params, 'until');
        if ($until !== null) {
            $request['endTime'] = $until;
            $params = $this->omit($params, 'until');
        }
        if ($limit !== null) {
            $request['count'] = $limit;
        }
        $orderID = $this->safe_string($params, 'orderID');
        if ($orderID !== null) {
            $request['orderID'] = $orderID;
            $params = $this->omit($params, 'orderID');
        }
        $clOrderID = $this->safe_string($params, 'clOrderID');
        if ($clOrderID !== null) {
            $request['clOrderID'] = $clOrderID;
            $params = $this->omit($params, 'clOrderID');
        }
        $includeOld = $this->safe_bool($params, 'includeOld');
        if ($includeOld !== null) {
            $request['includeOld'] = $includeOld;
            $params = $this->omit($params, 'includeOld');
        }
        $response = $this->privateGetApiV23UserTradeHistory ($this->extend($request, $params));
        return $this->parse_trades($response, $market, $since, $limit);
    }

    public function fetch_positions(?array $symbols = null, $params = array ()) {
        /**
         * fetch all open positions
         *
         * @see https://btsecom.github.io/docs/futuresV2_3/en/#query-$position
         *
         * @param {string[]} [$symbols] list of unified market $symbols
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=$position-structure $position structure~
         */
        $this->load_markets();
        $response = $this->privateGetApiV23UserPositions ($params);
        $result = array();
        for ($i = 0; $i < count($response); $i++) {
            $position = $response[$i];
            $parsed = $this->parse_position($position);
            $result[] = $parsed;
        }
        return $this->filter_by_array_positions($result, 'symbol', $symbols, false);
    }

    public function parse_position($position, ?array $market = null): array {
        $marketId = $this->safe_string($position, 'symbol');
        $market = $this->safe_market($marketId, $market);
        $symbol = $market['symbol'];
        $sideString = $this->safe_string($position, 'side');
        $side = ($sideString === 'BUY') ? 'long' : 'short';
        $contractsString = $this->safe_string($position, 'size');
        $entryPriceString = $this->safe_string($position, 'entryPrice');
        $markPriceString = $this->safe_string($position, 'markPrice');
        $unrealizedPnl = $this->safe_string($position, 'unrealizedProfitLoss');
        $liquidationPrice = $this->safe_string($position, 'liquidationPrice');
        $notional = $this->safe_string($position, 'orderValue');
        $marginType = $this->safe_integer($position, 'marginType');
        $marginMode = ($marginType === 91) ? 'cross' : 'isolated';
        return $this->safe_position(array(
            'info' => $position,
            'id' => $this->safe_string($position, 'positionId'),
            'symbol' => $symbol,
            'timestamp' => null,
            'datetime' => null,
            'initialMargin' => null,
            'initialMarginPercentage' => null,
            'maintenanceMargin' => $this->safe_string($position, 'totalMaintenanceMargin'),
            'maintenanceMarginPercentage' => null,
            'entryPrice' => $entryPriceString,
            'notional' => $notional,
            'leverage' => null,
            'unrealizedPnl' => $unrealizedPnl,
            'contracts' => $contractsString,
            'contractSize' => $market['contractSize'],
            'marginRatio' => null,
            'liquidationPrice' => $liquidationPrice,
            'markPrice' => $markPriceString,
            'collateral' => null,
            'marginMode' => $marginMode,
            'side' => $side,
            'percentage' => null,
        ));
    }

    public function set_leverage(float $leverage, ?string $symbol = null, $params = array ()) {
        /**
         * set the level of $leverage for a $market
         *
         * @see https://btsecom.github.io/docs/futuresV2_3/en/#set-$leverage
         *
         * @param {float} $leverage the rate of $leverage
         * @param {string} $symbol unified $market $symbol
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} $response from the exchange
         */
        if ($symbol === null) {
            throw new InvalidOrder($this->id . ' setLeverage() requires a $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
            'leverage' => $leverage,
        );
        $response = $this->privatePostApiV23Leverage ($this->extend($request, $params));
        return $response;
    }

    public function transfer(string $code, float $amount, string $fromAccount, string $toAccount, $params = array ()): array {
        /**
         * transfer $currency internally between wallets on the same account
         *
         * @see https://btsecom.github.io/docs/futuresV2_3/en/#wallet-transfer
         *
         * @param {string} $code unified $currency $code
         * @param {float} $amount amount to transfer
         * @param {string} $fromAccount account to transfer from
         * @param {string} $toAccount account to transfer to
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a ~@link https://docs.ccxt.com/#/?id=transfer-structure transfer structure~
         */
        $this->load_markets();
        $currency = $this->currency($code);
        $accountTypes = array(
            'spot' => 'SPOT',
            'cross' => 'CROSS',
            'isolated' => 'ISOLATED',
        );
        $fromType = $this->safe_string($accountTypes, $fromAccount, $fromAccount);
        $toType = $this->safe_string($accountTypes, $toAccount, $toAccount);
        $request = array(
            'walletSrcType' => $fromType,
            'walletDestType' => $toType,
            'apiWallets' => [
                array(
                    'currency' => $currency['id'],
                    'balance' => $this->currency_to_precision($code, $amount),
                ),
            ],
        );
        $response = $this->privatePostApiV23UserWalletTransfer ($this->extend($request, $params));
        return $this->parse_transfer($response, $currency);
    }

    public function parse_transfer(array $transfer, ?array $currency = null): array {
        return array(
            'info' => $transfer,
            'id' => $this->safe_string($transfer, 'transferId'),
            'timestamp' => $this->safe_integer($transfer, 'timestamp'),
            'datetime' => $this->safe_string($transfer, 'datetime'),
            'currency' => $this->safe_currency_code(null, $currency),
            'amount' => null,
            'fromAccount' => null,
            'toAccount' => null,
            'status' => null,
        );
    }
}

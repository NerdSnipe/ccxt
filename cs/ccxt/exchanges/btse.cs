namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class btse : Exchange
{
    public override object nonce()
    {
        return this.milliseconds();
    }

    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "btse" },
            { "name", "BTSE" },
            { "countries", new List<object>() {"KY"} },
            { "rateLimit", 67 },
            { "version", "v2.3" },
            { "certified", false },
            { "pro", false },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", false },
                { "margin", false },
                { "swap", true },
                { "future", true },
                { "option", false },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "createOrder", true },
                { "editOrder", true },
                { "fetchBalance", true },
                { "fetchCurrencies", false },
                { "fetchMarkets", true },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchPositions", true },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTrades", true },
                { "fetchTransfers", false },
                { "sandbox", true },
                { "setLeverage", true },
                { "setMarginMode", false },
                { "transfer", true },
            } },
            { "features", new Dictionary<string, object>() {
                { "swap", new Dictionary<string, object>() {
                    { "linear", new Dictionary<string, object>() {
                        { "sandbox", true },
                        { "createOrder", new Dictionary<string, object>() {
                            { "marginMode", false },
                            { "triggerPrice", true },
                            { "triggerPriceType", null },
                            { "triggerDirection", false },
                            { "stopLossPrice", true },
                            { "takeProfitPrice", true },
                            { "attachedStopLossTakeProfit", null },
                            { "timeInForce", new Dictionary<string, object>() {
                                { "GTC", true },
                                { "IOC", true },
                                { "FOK", true },
                                { "PO", true },
                                { "GTD", false },
                            } },
                            { "postOnly", true },
                            { "reduceOnly", true },
                            { "hedged", false },
                            { "trailing", false },
                            { "iceberg", false },
                            { "leverage", false },
                            { "marketBuyRequiresPrice", false },
                            { "marketBuyByCost", true },
                        } },
                        { "createOrders", new Dictionary<string, object>() {
                            { "max", 1 },
                        } },
                        { "fetchMyTrades", new Dictionary<string, object>() {
                            { "marginMode", false },
                            { "limit", 500 },
                            { "daysBack", null },
                            { "untilDays", null },
                            { "symbolRequired", false },
                        } },
                        { "fetchOrder", new Dictionary<string, object>() {
                            { "marginMode", false },
                            { "trigger", false },
                            { "trailing", false },
                            { "symbolRequired", true },
                        } },
                        { "fetchOpenOrders", new Dictionary<string, object>() {
                            { "marginMode", false },
                            { "limit", null },
                            { "trigger", false },
                            { "trailing", false },
                            { "symbolRequired", false },
                        } },
                        { "fetchOrders", null },
                        { "fetchClosedOrders", null },
                        { "fetchOHLCV", new Dictionary<string, object>() {
                            { "limit", null },
                        } },
                    } },
                } },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1" },
                { "5m", "5" },
                { "15m", "15" },
                { "30m", "30" },
                { "1h", "60" },
                { "2h", "120" },
                { "4h", "240" },
                { "6h", "360" },
                { "12h", "720" },
                { "1d", "1440" },
                { "3d", "4320" },
                { "1w", "10080" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/104117773-c7b2f880-52f4-11eb-8f2c-c21a4c626a32.jpg" },
                { "test", new Dictionary<string, object>() {
                    { "public", "https://testapi.btse.io/futures" },
                    { "private", "https://testapi.btse.io/futures" },
                } },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://api.btse.com/futures" },
                    { "private", "https://api.btse.com/futures" },
                } },
                { "www", "https://www.btse.com" },
                { "doc", new List<object>() {"https://btsecom.github.io/docs/futuresV2_3/en/"} },
                { "fees", "https://www.btse.com/en/fees" },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new List<object>() {"api/v2.3/market_summary", "api/v2.3/ohlcv", "api/v2.3/price", "api/v2.3/orderbook", "api/v2.3/trades"} },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new List<object>() {"api/v2.3/user/wallet", "api/v2.3/user/wallet_history", "api/v2.3/user/open_orders", "api/v2.3/user/positions", "api/v2.3/user/trade_history"} },
                    { "post", new List<object>() {"api/v2.3/order", "api/v2.3/user/wallet/transfer", "api/v2.3/leverage", "api/v2.3/position_mode"} },
                    { "put", new List<object>() {"api/v2.3/order"} },
                    { "delete", new List<object>() {"api/v2.3/order"} },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "percentage", true },
                    { "maker", this.parseNumber("0.0006") },
                    { "taker", this.parseNumber("0.0010") },
                } },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "INVALID_SYMBOL", typeof(BadSymbol) },
                    { "SYMBOL_NOT_FOUND", typeof(BadSymbol) },
                    { "INSUFFICIENT_BALANCE", typeof(InsufficientFunds) },
                    { "INSUFFICIENT_MARGIN", typeof(InsufficientFunds) },
                    { "INVALID_ORDER_SIZE", typeof(InvalidOrder) },
                    { "INVALID_PRICE", typeof(InvalidOrder) },
                    { "ORDER_SIZE_TOO_SMALL", typeof(InvalidOrder) },
                    { "ORDER_SIZE_TOO_LARGE", typeof(InvalidOrder) },
                    { "PRICE_TOO_HIGH", typeof(InvalidOrder) },
                    { "PRICE_TOO_LOW", typeof(InvalidOrder) },
                    { "ORDER_NOT_FOUND", typeof(OrderNotFound) },
                    { "ORDER_ALREADY_FILLED", typeof(OrderNotFound) },
                    { "ORDER_ALREADY_CANCELLED", typeof(OrderNotFound) },
                    { "RATE_LIMIT_EXCEEDED", typeof(RateLimitExceeded) },
                    { "TOO_MANY_REQUESTS", typeof(RateLimitExceeded) },
                    { "INVALID_API_KEY", typeof(AuthenticationError) },
                    { "INVALID_SIGNATURE", typeof(AuthenticationError) },
                    { "API_KEY_EXPIRED", typeof(AuthenticationError) },
                    { "PERMISSION_DENIED", typeof(PermissionDenied) },
                    { "IP_RESTRICTED", typeof(PermissionDenied) },
                    { "MARKET_CLOSED", typeof(InvalidOrder) },
                    { "MAINTENANCE_MODE", typeof(ExchangeNotAvailable) },
                    { "INVALID_NONCE", typeof(InvalidNonce) },
                    { "DUPLICATE_ORDER_ID", typeof(DuplicateOrderId) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "rate limit", typeof(RateLimitExceeded) },
                    { "too many", typeof(RateLimitExceeded) },
                    { "insufficient", typeof(InsufficientFunds) },
                    { "invalid", typeof(InvalidOrder) },
                    { "not found", typeof(OrderNotFound) },
                    { "permission", typeof(PermissionDenied) },
                    { "authentication", typeof(AuthenticationError) },
                    { "signature", typeof(AuthenticationError) },
                    { "maintenance", typeof(ExchangeNotAvailable) },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "options", new Dictionary<string, object>() {
                { "sandboxMode", false },
            } },
        });
    }

    public override void afterConstruct()
    {
        base.afterConstruct();
        // Check for whitelabel_domain in options
        object whitelabelDomain = this.safeString(this.options, "whitelabel_domain", null);
        if (isTrue(whitelabelDomain))
        {
            this.applyWhitelabelConfig(whitelabelDomain);
        }
    }

    public virtual void applyWhitelabelConfig(object domain)
    {
        object testnet = this.safeValue(this.options, "sandbox", false);
        // Construct URLs based on domain and testnet flag
        object apiHost = null;
        object testHost = null;
        if (isTrue(testnet))
        {
            apiHost = add(add("https://testapi.", domain), "/futures");
            testHost = apiHost;
        } else
        {
            apiHost = add(add("https://api.", domain), "/futures");
            testHost = add(add("https://testapi.", domain), "/futures");
        }
        // Override URLs
        ((IDictionary<string,object>)this.urls)["test"] = new Dictionary<string, object>() {
            { "public", testHost },
            { "private", testHost },
        };
        ((IDictionary<string,object>)this.urls)["api"] = new Dictionary<string, object>() {
            { "public", apiHost },
            { "private", apiHost },
        };
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object request = add("/", this.implodeParams(path, parameters));
        object url = add(getValue(getValue(this.urls, "api"), api), request);
        object query = this.omit(parameters, this.extractParams(path));
        if (isTrue(isEqual(api, "public")))
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
            {
                url = add(url, add("?", this.urlencode(query)));
            }
        } else
        {
            this.checkRequiredCredentials();
            object nonce = ((object)this.nonce()).ToString();
            object bodyStr = "";
            if (isTrue(isTrue(isEqual(method, "POST")) || isTrue(isEqual(method, "PUT"))))
            {
                if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
                {
                    body = this.json(query);
                    bodyStr = body;
                }
            } else if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
            {
                // Add query parameters to URL only, NOT to signature
                url = add(url, add("?", this.urlencode(query)));
            }
            // Signature: path + nonce + body (query params NOT included in signature)
            object auth = add(add(request, nonce), bodyStr);
            object signature = this.hmac(this.encode(auth), this.encode(this.secret), sha384, "hex");
            headers = new Dictionary<string, object>() {
                { "request-api", this.apiKey },
                { "request-nonce", nonce },
                { "request-sign", signature },
                { "Content-Type", "application/json" },
            };
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;
        }
        object errorCode = this.safeString(response, "errorCode");
        object message = this.safeString(response, "message", "");
        if (isTrue(!isEqual(errorCode, null)))
        {
            object feedback = add(add(this.id, " "), body);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }

    /**
     * @method
     * @name btse#fetchMarkets
     * @description retrieves data on all markets for btse
     * @see https://btsecom.github.io/docs/futuresV2_3/en/#market-summary
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetApiV23MarketSummary(parameters);
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object market = getValue(response, i);
            object parsed = this.parseMarket(market);
            ((IList<object>)result).Add(parsed);
        }
        return result;
    }

    public override object parseMarket(object market)
    {
        object id = this.safeString(market, "symbol");
        object baseId = this.safeString(market, "base");
        object quoteId = this.safeString(market, "quote");
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object settle = quote;
        object settleId = quoteId;
        object symbol = add(add(add(add(bs, "/"), quote), ":"), settle);
        object active = this.safeBool(market, "active", true);
        object minPriceIncrement = this.safeString(market, "minPriceIncrement");
        object minSizeIncrement = this.safeString(market, "minSizeIncrement");
        object minOrderSize = this.safeString(market, "minOrderSize");
        object maxOrderSize = this.safeString(market, "maxOrderSize");
        object contractSize = this.safeString(market, "contractSize", "1");
        return new Dictionary<string, object>() {
            { "id", id },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "settle", settle },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", settleId },
            { "type", "swap" },
            { "spot", false },
            { "margin", false },
            { "swap", true },
            { "future", false },
            { "option", false },
            { "active", active },
            { "contract", true },
            { "linear", true },
            { "inverse", false },
            { "contractSize", this.parseNumber(contractSize) },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", this.parseNumber(minSizeIncrement) },
                { "price", this.parseNumber(minPriceIncrement) },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", this.parseNumber(minOrderSize) },
                    { "max", this.parseNumber(maxOrderSize) },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", this.parseNumber(minPriceIncrement) },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            } },
            { "created", null },
            { "info", market },
        };
    }

    /**
     * @method
     * @name btse#fetchTicker
     * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://btsecom.github.io/docs/futuresV2_3/en/#market-summary
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetApiV23MarketSummary(this.extend(request, parameters));
        object ticker = this.safeDict(response, 0);
        return this.parseTicker(ticker, market);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        object marketId = this.safeString(ticker, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        object last = this.safeString(ticker, "last");
        object percentage = this.safeString(ticker, "percentageChange");
        object baseVolume = this.safeString(ticker, "volume");
        object high = this.safeString(ticker, "high24Hr");
        object low = this.safeString(ticker, "low24Hr");
        object bid = this.safeString(ticker, "highestBid");
        object ask = this.safeString(ticker, "lowestAsk");
        object size = this.safeString(ticker, "size");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", null },
            { "datetime", null },
            { "high", high },
            { "low", low },
            { "bid", bid },
            { "bidVolume", null },
            { "ask", ask },
            { "askVolume", null },
            { "vwap", null },
            { "open", null },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", percentage },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", size },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name btse#fetchOrderBook
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://btsecom.github.io/docs/futuresV2_3/en/#orderbook
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.group] orderbook grouping level (0-8)
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetApiV23Orderbook(this.extend(request, parameters));
        object timestamp = this.safeInteger(response, "timestamp");
        return this.parseOrderBook(response, symbol, timestamp, "buyQuote", "sellQuote", "price", "size");
    }

    /**
     * @method
     * @name btse#fetchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://btsecom.github.io/docs/futuresV2_3/en/#trades
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest trade to fetch
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "count", ((bool) isTrue(!isEqual(limit, null))) ? limit : 100 },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            parameters = this.omit(parameters, "until");
            ((IDictionary<string,object>)request)["endTime"] = until;
        }
        object response = await this.publicGetApiV23Trades(this.extend(request, parameters));
        return this.parseTrades(response, market, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        object marketId = this.safeString(trade, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        object timestamp = this.safeInteger(trade, "timestamp");
        object side = this.safeStringLower(trade, "side");
        object priceString = this.safeString2(trade, "filledPrice", "price");
        object amountString = this.safeString2(trade, "filledSize", "size");
        object id = this.safeString2(trade, "tradeId", "serialId");
        object orderId = this.safeString(trade, "orderId");
        object feeAmount = this.safeString(trade, "feeAmount");
        object feeCurrency = this.safeString(trade, "feeCurrency");
        object fee = ((bool) isTrue((!isEqual(feeAmount, null)))) ? new Dictionary<string, object>() {
    { "cost", feeAmount },
    { "currency", this.safeCurrencyCode(feeCurrency) },
} : null;
        object costString = this.safeString(trade, "total");
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", id },
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "type", null },
            { "side", side },
            { "order", orderId },
            { "takerOrMaker", null },
            { "price", priceString },
            { "amount", amountString },
            { "cost", costString },
            { "fee", fee },
        }, market);
    }

    /**
     * @method
     * @name btse#fetchOHLCV
     * @description fetches historical candlestick data containing the open, high, low, close price, and the volume of a market
     * @see https://btsecom.github.io/docs/futuresV2_3/en/#ohlcv
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest candle to fetch
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "resolution", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start"] = since;
        }
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            parameters = this.omit(parameters, "until");
            ((IDictionary<string,object>)request)["end"] = until;
        }
        object response = await this.publicGetApiV23Ohlcv(this.extend(request, parameters));
        return this.parseOHLCVs(response, market, timeframe, since, limit);
    }

    /**
     * @method
     * @name btse#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://btsecom.github.io/docs/futuresV2_3/en/#wallet
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.wallet] wallet name, defaults to 'CROSS@'
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object wallet = this.safeString(parameters, "wallet", "CROSS@");
        object request = new Dictionary<string, object>() {
            { "wallet", wallet },
        };
        object response = await this.privateGetApiV23UserWallet(this.extend(request, parameters));
        return this.parseBalance(response);
    }

    public override object parseBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object wallets = this.safeList(response, 0, new List<object>() {});
        if (isTrue(isEqual(getArrayLength(wallets), 0)))
        {
            return this.safeBalance(result);
        }
        object wallet = this.safeDict(response, 0);
        object assets = this.safeList(wallet, "assets", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(assets)); postFixIncrement(ref i))
        {
            object asset = getValue(assets, i);
            object currencyId = this.safeString(asset, "currency");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((IDictionary<string,object>)account)["total"] = this.safeString(asset, "balance");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        object availableBalance = this.safeString(wallet, "availableBalance");
        object marginBalance = this.safeString(wallet, "marginBalance");
        if (isTrue(isTrue(!isEqual(availableBalance, null)) || isTrue(!isEqual(marginBalance, null))))
        {
            ((IDictionary<string,object>)result)["free"] = availableBalance;
            ((IDictionary<string,object>)result)["used"] = marginBalance;
            ((IDictionary<string,object>)result)["total"] = this.safeString(wallet, "totalValue");
        }
        return this.safeBalance(result);
    }

    /**
     * @method
     * @name btse#createOrder
     * @description create a trade order
     * @see https://btsecom.github.io/docs/futuresV2_3/en/#order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much you want to trade in units of the base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.timeInForce] 'GTC', 'IOC', 'FOK', or 'PO'
     * @param {bool} [params.postOnly] true or false
     * @param {bool} [params.reduceOnly] true or false
     * @param {float} [params.triggerPrice] price to trigger stop orders
     * @param {float} [params.stopPrice] price for OCO orders
     * @param {float} [params.takeProfitPrice] take profit trigger price
     * @param {float} [params.stopLossPrice] stop loss trigger price
     * @param {string} [params.clOrderID] client order ID
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object uppercaseType = ((string)type).ToUpper();
        object uppercaseSide = ((string)side).ToUpper();
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "side", uppercaseSide },
            { "type", uppercaseType },
            { "size", this.amountToPrecision(symbol, amount) },
        };
        if (isTrue(isEqual(uppercaseType, "LIMIT")))
        {
            if (isTrue(isEqual(price, null)))
            {
                throw new InvalidOrder ((string)add(this.id, " createOrder() requires a price argument for limit orders")) ;
            }
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object timeInForce = this.safeString(parameters, "timeInForce");
        if (isTrue(!isEqual(timeInForce, null)))
        {
            ((IDictionary<string,object>)request)["time_in_force"] = timeInForce;
        }
        object postOnly = this.safeBool(parameters, "postOnly");
        if (isTrue(!isEqual(postOnly, null)))
        {
            ((IDictionary<string,object>)request)["postOnly"] = postOnly;
        }
        object reduceOnly = this.safeBool(parameters, "reduceOnly");
        if (isTrue(!isEqual(reduceOnly, null)))
        {
            ((IDictionary<string,object>)request)["reduceOnly"] = reduceOnly;
        }
        object triggerPrice = this.safeString(parameters, "triggerPrice");
        if (isTrue(!isEqual(triggerPrice, null)))
        {
            ((IDictionary<string,object>)request)["triggerPrice"] = this.priceToPrecision(symbol, triggerPrice);
        }
        object stopPrice = this.safeString(parameters, "stopPrice");
        if (isTrue(!isEqual(stopPrice, null)))
        {
            ((IDictionary<string,object>)request)["stopPrice"] = this.priceToPrecision(symbol, stopPrice);
        }
        object takeProfitPrice = this.safeString(parameters, "takeProfitPrice");
        if (isTrue(!isEqual(takeProfitPrice, null)))
        {
            ((IDictionary<string,object>)request)["takeProfitPrice"] = this.priceToPrecision(symbol, takeProfitPrice);
        }
        object stopLossPrice = this.safeString(parameters, "stopLossPrice");
        if (isTrue(!isEqual(stopLossPrice, null)))
        {
            ((IDictionary<string,object>)request)["stopLossPrice"] = this.priceToPrecision(symbol, stopLossPrice);
        }
        object clientOrderId = this.safeString(parameters, "clOrderID");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["clOrderID"] = clientOrderId;
        }
        parameters = this.omit(parameters, new List<object>() {"timeInForce", "postOnly", "reduceOnly", "triggerPrice", "stopPrice", "takeProfitPrice", "stopLossPrice", "clOrderID"});
        object response = await this.privatePostApiV23Order(this.extend(request, parameters));
        object order = ((bool) isTrue(((response is IList<object>) || (response.GetType().IsGenericType && response.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))) ? getValue(response, 0) : response;
        return this.parseOrder(order, market);
    }

    public override object parseOrder(object order, object market = null)
    {
        object marketId = this.safeString(order, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        object orderId = this.safeString(order, "orderID");
        object clientOrderId = this.safeString(order, "clOrderID");
        object timestamp = this.safeInteger(order, "timestamp");
        object side = this.safeStringLower(order, "side");
        object type = this.safeStringLower(order, "type");
        object price = this.safeString(order, "price");
        object amount = this.safeString(order, "originalOrderSize");
        object filled = this.safeString(order, "filledSize");
        object remaining = this.safeString(order, "currentOrderSize");
        object status = this.parseOrderStatus(this.safeString(order, "status"));
        object average = this.safeString(order, "avgFillPrice");
        object timeInForce = this.safeString(order, "timeInForce");
        object postOnly = this.safeBool(order, "postOnly");
        object reduceOnly = this.safeBool(order, "reduceOnly");
        object triggerPrice = this.safeString(order, "triggerPrice");
        object stopPrice = this.safeString(order, "stopPrice");
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", orderId },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "status", status },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", timeInForce },
            { "postOnly", postOnly },
            { "reduceOnly", reduceOnly },
            { "side", side },
            { "price", price },
            { "stopPrice", stopPrice },
            { "triggerPrice", triggerPrice },
            { "amount", amount },
            { "filled", filled },
            { "remaining", remaining },
            { "cost", null },
            { "average", average },
            { "trades", null },
            { "fee", null },
            { "info", order },
        }, market);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "1", "open" },
            { "2", "open" },
            { "4", "closed" },
            { "5", "canceled" },
            { "6", "open" },
            { "8", "canceled" },
            { "9", "canceled" },
            { "10", "canceled" },
            { "15", "rejected" },
        };
        return this.safeString(statuses, status, status);
    }

    /**
     * @method
     * @name btse#cancelOrder
     * @description cancels an open order
     * @see https://btsecom.github.io/docs/futuresV2_3/en/#order-2
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.clOrderID] client order id
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new InvalidOrder ((string)add(this.id, " cancelOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object clientOrderId = this.safeString(parameters, "clOrderID");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["clOrderID"] = clientOrderId;
            parameters = this.omit(parameters, "clOrderID");
        } else
        {
            ((IDictionary<string,object>)request)["orderID"] = id;
        }
        object response = await this.privateDeleteApiV23Order(this.extend(request, parameters));
        return this.parseOrder(response, market);
    }

    /**
     * @method
     * @name btse#cancelAllOrders
     * @description cancel all open orders in a market
     * @see https://btsecom.github.io/docs/futuresV2_3/en/#order-2
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new InvalidOrder ((string)add(this.id, " cancelAllOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.privateDeleteApiV23Order(this.extend(request, parameters));
        if (isTrue(((response is IList<object>) || (response.GetType().IsGenericType && response.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            return this.parseOrders(response, market);
        }
        return new List<object> {this.parseOrder(response, market)};
    }

    /**
     * @method
     * @name btse#editOrder
     * @description edit a trade order
     * @see https://btsecom.github.io/docs/futuresV2_3/en/#order-1
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market to edit the order in
     * @param {string} type not used by btse editOrder
     * @param {string} side not used by btse editOrder
     * @param {float} [amount] how much you want to trade in units of the base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {float} [params.triggerPrice] price to trigger stop orders
     * @param {string} [params.clOrderID] client order id
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object clientOrderId = this.safeString(parameters, "clOrderID");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["clOrderID"] = clientOrderId;
            parameters = this.omit(parameters, "clOrderID");
        } else
        {
            ((IDictionary<string,object>)request)["orderID"] = id;
        }
        object triggerPrice = this.safeString(parameters, "triggerPrice");
        if (isTrue(isTrue(isTrue(!isEqual(price, null)) && isTrue(!isEqual(amount, null))) && isTrue(!isEqual(triggerPrice, null))))
        {
            ((IDictionary<string,object>)request)["type"] = "ALL";
            ((IDictionary<string,object>)request)["orderPrice"] = this.priceToPrecision(symbol, price);
            ((IDictionary<string,object>)request)["orderSize"] = this.amountToPrecision(symbol, amount);
            ((IDictionary<string,object>)request)["triggerPrice"] = this.priceToPrecision(symbol, triggerPrice);
            parameters = this.omit(parameters, "triggerPrice");
        } else if (isTrue(isTrue(!isEqual(price, null)) && isTrue(!isEqual(amount, null))))
        {
            ((IDictionary<string,object>)request)["type"] = "ALL";
            ((IDictionary<string,object>)request)["orderPrice"] = this.priceToPrecision(symbol, price);
            ((IDictionary<string,object>)request)["orderSize"] = this.amountToPrecision(symbol, amount);
        } else if (isTrue(!isEqual(price, null)))
        {
            ((IDictionary<string,object>)request)["type"] = "PRICE";
            ((IDictionary<string,object>)request)["value"] = this.priceToPrecision(symbol, price);
        } else if (isTrue(!isEqual(amount, null)))
        {
            ((IDictionary<string,object>)request)["type"] = "SIZE";
            ((IDictionary<string,object>)request)["value"] = this.amountToPrecision(symbol, amount);
        } else if (isTrue(!isEqual(triggerPrice, null)))
        {
            ((IDictionary<string,object>)request)["type"] = "TRIGGERPRICE";
            ((IDictionary<string,object>)request)["value"] = this.priceToPrecision(symbol, triggerPrice);
            parameters = this.omit(parameters, "triggerPrice");
        } else
        {
            throw new InvalidOrder ((string)add(this.id, " editOrder() requires a price, amount, or triggerPrice argument")) ;
        }
        object response = await this.privatePutApiV23Order(this.extend(request, parameters));
        return this.parseOrder(response, market);
    }

    /**
     * @method
     * @name btse#fetchOpenOrders
     * @description fetch all unfilled currently open orders
     * @see https://btsecom.github.io/docs/futuresV2_3/en/#query-open-orders
     * @param {string} symbol unified market symbol
     * @param {int} [since] not used by btse fetchOpenOrders
     * @param {int} [limit] not used by btse fetchOpenOrders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object response = await this.privateGetApiV23UserOpenOrders(this.extend(request, parameters));
        return this.parseOrders(response, market, since, limit);
    }

    /**
     * @method
     * @name btse#fetchOrder
     * @description fetches information on an order made by the user
     * @see https://btsecom.github.io/docs/futuresV2_3/en/#query-open-orders
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.clOrderID] client order id
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object clientOrderId = this.safeString(parameters, "clOrderID");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["clOrderID"] = clientOrderId;
            parameters = this.omit(parameters, "clOrderID");
        } else
        {
            ((IDictionary<string,object>)request)["orderID"] = id;
        }
        object response = await this.privateGetApiV23UserOpenOrders(this.extend(request, parameters));
        if (isTrue(isTrue(((response is IList<object>) || (response.GetType().IsGenericType && response.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))) && isTrue(isGreaterThan(getArrayLength(response), 0))))
        {
            return this.parseOrder(getValue(response, 0), market);
        }
        throw new OrderNotFound ((string)add(add(this.id, " fetchOrder() could not find order "), id)) ;
    }

    /**
     * @method
     * @name btse#fetchMyTrades
     * @description fetch all trades made by the user
     * @see https://btsecom.github.io/docs/futuresV2_3/en/#query-trades-fills
     * @param {string} symbol unified market symbol
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum number of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest trade to fetch
     * @param {string} [params.orderID] filter trades by order ID
     * @param {string} [params.clOrderID] filter trades by client order ID
     * @param {bool} [params.includeOld] include trades older than 7 days
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
            parameters = this.omit(parameters, "until");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["count"] = limit;
        }
        object orderID = this.safeString(parameters, "orderID");
        if (isTrue(!isEqual(orderID, null)))
        {
            ((IDictionary<string,object>)request)["orderID"] = orderID;
            parameters = this.omit(parameters, "orderID");
        }
        object clOrderID = this.safeString(parameters, "clOrderID");
        if (isTrue(!isEqual(clOrderID, null)))
        {
            ((IDictionary<string,object>)request)["clOrderID"] = clOrderID;
            parameters = this.omit(parameters, "clOrderID");
        }
        object includeOld = this.safeBool(parameters, "includeOld");
        if (isTrue(!isEqual(includeOld, null)))
        {
            ((IDictionary<string,object>)request)["includeOld"] = includeOld;
            parameters = this.omit(parameters, "includeOld");
        }
        object response = await this.privateGetApiV23UserTradeHistory(this.extend(request, parameters));
        return this.parseTrades(response, market, since, limit);
    }

    /**
     * @method
     * @name btse#fetchPositions
     * @description fetch all open positions
     * @see https://btsecom.github.io/docs/futuresV2_3/en/#query-position
     * @param {string[]} [symbols] list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetApiV23UserPositions(parameters);
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object position = getValue(response, i);
            object parsed = this.parsePosition(position);
            ((IList<object>)result).Add(parsed);
        }
        return this.filterByArrayPositions(result, "symbol", symbols, false);
    }

    public override object parsePosition(object position, object market = null)
    {
        object marketId = this.safeString(position, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object sideString = this.safeString(position, "side");
        object side = ((bool) isTrue((isEqual(sideString, "BUY")))) ? "long" : "short";
        object contractsString = this.safeString(position, "size");
        object entryPriceString = this.safeString(position, "entryPrice");
        object markPriceString = this.safeString(position, "markPrice");
        object unrealizedPnl = this.safeString(position, "unrealizedProfitLoss");
        object liquidationPrice = this.safeString(position, "liquidationPrice");
        object notional = this.safeString(position, "orderValue");
        object marginType = this.safeInteger(position, "marginType");
        object marginMode = ((bool) isTrue((isEqual(marginType, 91)))) ? "cross" : "isolated";
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", this.safeString(position, "positionId") },
            { "symbol", symbol },
            { "timestamp", null },
            { "datetime", null },
            { "initialMargin", null },
            { "initialMarginPercentage", null },
            { "maintenanceMargin", this.safeString(position, "totalMaintenanceMargin") },
            { "maintenanceMarginPercentage", null },
            { "entryPrice", entryPriceString },
            { "notional", notional },
            { "leverage", null },
            { "unrealizedPnl", unrealizedPnl },
            { "contracts", contractsString },
            { "contractSize", getValue(market, "contractSize") },
            { "marginRatio", null },
            { "liquidationPrice", liquidationPrice },
            { "markPrice", markPriceString },
            { "collateral", null },
            { "marginMode", marginMode },
            { "side", side },
            { "percentage", null },
        });
    }

    /**
     * @method
     * @name btse#setLeverage
     * @description set the level of leverage for a market
     * @see https://btsecom.github.io/docs/futuresV2_3/en/#set-leverage
     * @param {float} leverage the rate of leverage
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} response from the exchange
     */
    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new InvalidOrder ((string)add(this.id, " setLeverage() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "leverage", leverage },
        };
        object response = await this.privatePostApiV23Leverage(this.extend(request, parameters));
        return response;
    }

    /**
     * @method
     * @name btse#transfer
     * @description transfer currency internally between wallets on the same account
     * @see https://btsecom.github.io/docs/futuresV2_3/en/#wallet-transfer
     * @param {string} code unified currency code
     * @param {float} amount amount to transfer
     * @param {string} fromAccount account to transfer from
     * @param {string} toAccount account to transfer to
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
     */
    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object accountTypes = new Dictionary<string, object>() {
            { "spot", "SPOT" },
            { "cross", "CROSS" },
            { "isolated", "ISOLATED" },
        };
        object fromType = this.safeString(accountTypes, fromAccount, fromAccount);
        object toType = this.safeString(accountTypes, toAccount, toAccount);
        object request = new Dictionary<string, object>() {
            { "walletSrcType", fromType },
            { "walletDestType", toType },
            { "apiWallets", new List<object>() {new Dictionary<string, object>() {
    { "currency", getValue(currency, "id") },
    { "balance", this.currencyToPrecision(code, amount) },
}} },
        };
        object response = await this.privatePostApiV23UserWalletTransfer(this.extend(request, parameters));
        return this.parseTransfer(response, currency);
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        return new Dictionary<string, object>() {
            { "info", transfer },
            { "id", this.safeString(transfer, "transferId") },
            { "timestamp", this.safeInteger(transfer, "timestamp") },
            { "datetime", this.safeString(transfer, "datetime") },
            { "currency", this.safeCurrencyCode(null, currency) },
            { "amount", null },
            { "fromAccount", null },
            { "toAccount", null },
            { "status", null },
        };
    }
}

package base
import "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


    func CreateOrderAfterDelay(exchange ccxt.ICoreExchange) <- chan interface{} {
                ch := make(chan interface{})
                go func() interface{} {
                    defer close(ch)
                    defer ReturnPanicError(ch)
                    
                retRes54 := (<-exchange.Sleep(3000))
                PanicOnError(retRes54)
            
                retRes64 := (<-exchange.CreateOrder("BTC/USDT:USDT", "market", "buy", 0.001))
                PanicOnError(retRes64)
                    return nil
                }()
                return ch
            }
    func TestUnWatchPositions(exchange ccxt.ICoreExchange, skippedProperties interface{}, symbol interface{}) <- chan interface{} {
                ch := make(chan interface{})
                go func() interface{} {
                    defer close(ch)
                    defer ReturnPanicError(ch)
                        var method interface{} = "unWatchPositions"
                exchange.SetSandboxMode(true)
                // First, we need to subscribe to positions to test the unsubscribe functionality
                var positionsSubscription interface{} = nil
                
                    {		
                         func(this *undefined) (ret_ interface{}) {
                		    defer func() {
                                if e := recover(); e != nil {
                                    if e == "break" {
                                        return
                                    }
                                    ret_ = func(this *undefined) interface{} {
                                        // catch block:
                                                if !IsTrue(IsTemporaryFailure(e)) {
                            panic(e)
                        }
                
                                // If we can't subscribe, we can't test unsubscribe, so skip this test
                ch <- false
                        return nil
                                        
                                    }(this)
                                }
                            }()
                		    // try block:
                                    // First call uses snapshot
                        
                    positionsSubscription = (UnWrapType(<-exchange.WatchPositions()))
                            PanicOnError(positionsSubscription)
                        // trigger a position update
                        exchange.Spawn(CreateOrderAfterDelay, exchange)
                        // Second call uses subscription
                        
                    positionsSubscription = (UnWrapType(<-exchange.WatchPositions()))
                            PanicOnError(positionsSubscription)
                		    return nil
                	    }(this)
                    
                        }
                // Verify that we have a subscription
                Assert(IsArray(positionsSubscription), Add(Add(Add(exchange.GetId(), " "), method), " requires a valid positions subscription to test unsubscribe"))
                // Assert unWatchPositions for one symbol is not supported
                var errorResponse interface{} = nil
                
                    {		
                         func(this *undefined) (ret_ interface{}) {
                		    defer func() {
                                if e := recover(); e != nil {
                                    if e == "break" {
                                        return
                                    }
                                    ret_ = func(this *undefined) interface{} {
                                        // catch block:
                                                errorResponse = e
                                        return nil
                                    }(this)
                                }
                            }()
                		    // try block:
                                    
                    errorResponse = (<-exchange.UnWatchPositions([]interface{}{symbol}))
                            PanicOnError(errorResponse)
                		    return nil
                	    }(this)
                    
                        }
                Assert(!IsEqual(errorResponse, nil), Add(Add(Add(Add(exchange.GetId(), " "), method), " must throw an error when unwatching a specific symbol, returned "), exchange.Json(errorResponse)))
                // Test unwatching all positions (without specific symbols)
                var responseAll interface{} = nil
                
                    {		
                         func(this *undefined) (ret_ interface{}) {
                		    defer func() {
                                if e := recover(); e != nil {
                                    if e == "break" {
                                        return
                                    }
                                    ret_ = func(this *undefined) interface{} {
                                        // catch block:
                                                if !IsTrue(IsTemporaryFailure(e)) {
                            panic(e)
                        }
                        panic(e)
                                        
                                    }(this)
                                }
                            }()
                		    // try block:
                                    
                    responseAll = (<-exchange.UnWatchPositions())
                            PanicOnError(responseAll)
                		    return nil
                	    }(this)
                    
                        }
                // Verify the response for unwatching all positions
                Assert(!IsEqual(responseAll, nil), Add(Add(Add(Add(exchange.GetId(), " "), method), " must return a response when unwatching all positions, returned "), exchange.Json(responseAll)))
                // Test that we can resubscribe after unwatching (to ensure cleanup was proper)
                var resubscribeResponse interface{} = nil
                
                    {		
                         func(this *undefined) (ret_ interface{}) {
                		    defer func() {
                                if e := recover(); e != nil {
                                    if e == "break" {
                                        return
                                    }
                                    ret_ = func(this *undefined) interface{} {
                                        // catch block:
                                                if !IsTrue(IsTemporaryFailure(e)) {
                            panic(e)
                        }
                        panic(Error(Add(Add(Add(exchange.GetId(), " "), method), " failed to resubscribe after unwatch, indicating potential cleanup issues")))
                                        
                                    }(this)
                                }
                            }()
                		    // try block:
                                    
                    resubscribeResponse = (UnWrapType(<-exchange.WatchPositions()))
                            PanicOnError(resubscribeResponse)
                        exchange.Spawn(CreateOrderAfterDelay, exchange)
                        
                    resubscribeResponse = (UnWrapType(<-exchange.WatchPositions()))
                            PanicOnError(resubscribeResponse)
                		    return nil
                	    }(this)
                    
                        }
                // Verify resubscription works
                Assert(IsArray(resubscribeResponse), Add(Add(Add(Add(exchange.GetId(), " "), method), " must allow resubscription after unwatch, returned "), exchange.Json(resubscribeResponse)))
            
                ch <- true
                return nil
            
                }()
                return ch
            }

package ccxt


// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type BtseCore struct {
    Exchange

}

func NewBtseCore() *BtseCore {
    p := &BtseCore{}
    setDefaults(p)
    return p
}

func  (this *BtseCore) Nonce() interface{}  {
    return this.Milliseconds()
}
func  (this *BtseCore) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "btse",
        "name": "BTSE",
        "countries": []interface{}{"KY"},
        "rateLimit": 67,
        "version": "v2.3",
        "certified": false,
        "pro": false,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": false,
            "swap": true,
            "future": true,
            "option": false,
            "cancelAllOrders": true,
            "cancelOrder": true,
            "createOrder": true,
            "editOrder": true,
            "fetchBalance": true,
            "fetchCurrencies": false,
            "fetchMarkets": true,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchPositions": true,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTrades": true,
            "fetchTransfers": false,
            "sandbox": true,
            "setLeverage": true,
            "setMarginMode": false,
            "transfer": true,
        },
        "features": map[string]interface{} {
            "swap": map[string]interface{} {
                "linear": map[string]interface{} {
                    "sandbox": true,
                    "createOrder": map[string]interface{} {
                        "marginMode": false,
                        "triggerPrice": true,
                        "triggerPriceType": nil,
                        "triggerDirection": false,
                        "stopLossPrice": true,
                        "takeProfitPrice": true,
                        "attachedStopLossTakeProfit": nil,
                        "timeInForce": map[string]interface{} {
                            "GTC": true,
                            "IOC": true,
                            "FOK": true,
                            "PO": true,
                            "GTD": false,
                        },
                        "postOnly": true,
                        "reduceOnly": true,
                        "hedged": false,
                        "trailing": false,
                        "iceberg": false,
                        "leverage": false,
                        "marketBuyRequiresPrice": false,
                        "marketBuyByCost": true,
                    },
                    "createOrders": map[string]interface{} {
                        "max": 1,
                    },
                    "fetchMyTrades": map[string]interface{} {
                        "marginMode": false,
                        "limit": 500,
                        "daysBack": nil,
                        "untilDays": nil,
                        "symbolRequired": false,
                    },
                    "fetchOrder": map[string]interface{} {
                        "marginMode": false,
                        "trigger": false,
                        "trailing": false,
                        "symbolRequired": true,
                    },
                    "fetchOpenOrders": map[string]interface{} {
                        "marginMode": false,
                        "limit": nil,
                        "trigger": false,
                        "trailing": false,
                        "symbolRequired": false,
                    },
                    "fetchOrders": nil,
                    "fetchClosedOrders": nil,
                    "fetchOHLCV": map[string]interface{} {
                        "limit": nil,
                    },
                },
            },
        },
        "timeframes": map[string]interface{} {
            "1m": "1",
            "5m": "5",
            "15m": "15",
            "30m": "30",
            "1h": "60",
            "2h": "120",
            "4h": "240",
            "6h": "360",
            "12h": "720",
            "1d": "1440",
            "3d": "4320",
            "1w": "10080",
        },
        "urls": map[string]interface{} {
            "logo": "https://user-images.githubusercontent.com/1294454/104117773-c7b2f880-52f4-11eb-8f2c-c21a4c626a32.jpg",
            "test": map[string]interface{} {
                "public": "https://testapi.btse.io/futures",
                "private": "https://testapi.btse.io/futures",
                "publicSpot": "https://testapi.btse.io/spot",
                "privateSpot": "https://testapi.btse.io/spot",
            },
            "api": map[string]interface{} {
                "public": "https://api.btse.com/futures",
                "private": "https://api.btse.com/futures",
                "publicSpot": "https://api.btse.com/spot",
                "privateSpot": "https://api.btse.com/spot",
            },
            "www": "https://www.btse.com",
            "doc": []interface{}{"https://btsecom.github.io/docs/futuresV2_3/en/", "https://btsecom.github.io/docs/spotV3_3/en/"},
            "fees": "https://www.btse.com/en/fees",
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": []interface{}{"api/v2.3/market_summary", "api/v2.3/ohlcv", "api/v2.3/price", "api/v2.3/orderbook", "api/v2.3/trades"},
            },
            "publicSpot": map[string]interface{} {
                "get": []interface{}{"api/v3.2/market_summary", "api/v3.2/ohlcv", "api/v3.2/price", "api/v3.2/orderbook/L2", "api/v3.2/trades"},
            },
            "private": map[string]interface{} {
                "get": []interface{}{"api/v2.3/user/wallet", "api/v2.3/user/wallet_history", "api/v2.3/user/open_orders", "api/v2.3/user/positions", "api/v2.3/user/trade_history"},
                "post": []interface{}{"api/v2.3/order", "api/v2.3/user/wallet/transfer", "api/v2.3/leverage", "api/v2.3/position_mode"},
                "put": []interface{}{"api/v2.3/order"},
                "delete": []interface{}{"api/v2.3/order"},
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "tierBased": true,
                "percentage": true,
                "maker": this.ParseNumber("0.0006"),
                "taker": this.ParseNumber("0.0010"),
            },
        },
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "INVALID_SYMBOL": BadSymbol,
                "SYMBOL_NOT_FOUND": BadSymbol,
                "INSUFFICIENT_BALANCE": InsufficientFunds,
                "INSUFFICIENT_MARGIN": InsufficientFunds,
                "INVALID_ORDER_SIZE": InvalidOrder,
                "INVALID_PRICE": InvalidOrder,
                "ORDER_SIZE_TOO_SMALL": InvalidOrder,
                "ORDER_SIZE_TOO_LARGE": InvalidOrder,
                "PRICE_TOO_HIGH": InvalidOrder,
                "PRICE_TOO_LOW": InvalidOrder,
                "ORDER_NOT_FOUND": OrderNotFound,
                "ORDER_ALREADY_FILLED": OrderNotFound,
                "ORDER_ALREADY_CANCELLED": OrderNotFound,
                "RATE_LIMIT_EXCEEDED": RateLimitExceeded,
                "TOO_MANY_REQUESTS": RateLimitExceeded,
                "INVALID_API_KEY": AuthenticationError,
                "INVALID_SIGNATURE": AuthenticationError,
                "API_KEY_EXPIRED": AuthenticationError,
                "PERMISSION_DENIED": PermissionDenied,
                "IP_RESTRICTED": PermissionDenied,
                "MARKET_CLOSED": InvalidOrder,
                "MAINTENANCE_MODE": ExchangeNotAvailable,
                "INVALID_NONCE": InvalidNonce,
                "DUPLICATE_ORDER_ID": DuplicateOrderId,
            },
            "broad": map[string]interface{} {
                "rate limit": RateLimitExceeded,
                "too many": RateLimitExceeded,
                "insufficient": InsufficientFunds,
                "invalid": InvalidOrder,
                "not found": OrderNotFound,
                "permission": PermissionDenied,
                "authentication": AuthenticationError,
                "signature": AuthenticationError,
                "maintenance": ExchangeNotAvailable,
            },
        },
        "precisionMode": TICK_SIZE,
        "options": map[string]interface{} {
            "sandboxMode": false,
        },
    })
}
func  (this *BtseCore) AfterConstruct()  {
    this.Exchange.AfterConstruct()
    var whitelabelDomain interface{} = this.SafeString(this.Options, "whitelabel_domain")
    if IsTrue(!IsEqual(whitelabelDomain, nil)) {
        var testPublic interface{} = Add(Add("https://testapi.", whitelabelDomain), "/futures")
        var testPrivate interface{} = Add(Add("https://testapi.", whitelabelDomain), "/futures")
        var apiPublic interface{} = Add(Add("https://api.", whitelabelDomain), "/futures")
        var apiPrivate interface{} = Add(Add("https://api.", whitelabelDomain), "/futures")
        AddElementToObject(this.Urls, "test", map[string]interface{} {
    "public": testPublic,
    "private": testPrivate,
})
        AddElementToObject(this.Urls, "api", map[string]interface{} {
    "public": apiPublic,
    "private": apiPrivate,
})
    }
}
func  (this *BtseCore) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var request interface{} = Add("/", this.ImplodeParams(path, params))
    var url interface{} = Add(GetValue(GetValue(this.Urls, "api"), api), request)
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    var isPublic interface{} = IsTrue((IsEqual(api, "public"))) || IsTrue((IsEqual(api, "publicSpot")))
    if IsTrue(isPublic) {
        if IsTrue(GetArrayLength(ObjectKeys(query))) {
            url = Add(url, Add("?", this.Urlencode(query)))
        }
    } else {
        this.CheckRequiredCredentials()
        var nonce interface{} = ToString(this.Nonce())
        var bodyStr interface{} = ""
        if IsTrue(IsTrue(IsEqual(method, "POST")) || IsTrue(IsEqual(method, "PUT"))) {
            if IsTrue(GetArrayLength(ObjectKeys(query))) {
                body = this.Json(query)
                bodyStr = body
            }
        } else if IsTrue(GetArrayLength(ObjectKeys(query))) {
            // Add query parameters to URL only, NOT to signature
            url = Add(url, Add("?", this.Urlencode(query)))
        }
        // Signature: path + nonce + body (query params NOT included in signature)
        var auth interface{} = Add(Add(request, nonce), bodyStr)
        var signature interface{} = this.Hmac(this.Encode(auth), this.Encode(this.Secret), sha384, "hex")
        headers = map[string]interface{} {
            "request-api": this.ApiKey,
            "request-nonce": nonce,
            "request-sign": signature,
            "Content-Type": "application/json",
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *BtseCore) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil
    }
    var errorCode interface{} = this.SafeString(response, "errorCode")
    var message interface{} = this.SafeString(response, "message", "")
    if IsTrue(!IsEqual(errorCode, nil)) {
        var feedback interface{} = Add(Add(this.Id, " "), body)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errorCode, feedback)
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}
/**
 * @method
 * @name btse#fetchMarkets
 * @description retrieves data on all markets for btse
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#market-summary
 * @see https://btsecom.github.io/docs/spotV3_3/en/#market-summary
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *BtseCore) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    // Fetch both SPOT and FUTURES markets
            params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var promises interface{} = []interface{}{this.PublicGetApiV23MarketSummary(params), this.PublicSpotGetApiV32MarketSummary(params)}
        
            responses:= (<-promiseAll(promises))
            PanicOnError(responses)
            var futuresResponse interface{} = GetValue(responses, 0)
            var spotResponse interface{} = GetValue(responses, 1)
            var result interface{} = []interface{}{}
            // Parse FUTURES markets
            for i := 0; IsLessThan(i, GetArrayLength(futuresResponse)); i++ {
                var market interface{} = GetValue(futuresResponse, i)
                var parsed interface{} = this.ParseMarket(market)
                AppendToArray(&result, parsed)
            }
            // Parse SPOT markets
            for i := 0; IsLessThan(i, GetArrayLength(spotResponse)); i++ {
                var market interface{} = GetValue(spotResponse, i)
                var parsed interface{} = this.ParseMarket(market)
                AppendToArray(&result, parsed)
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *BtseCore) ParseMarket(market interface{}) interface{}  {
    var id interface{} = this.SafeString(market, "symbol")
    var baseId interface{} = this.SafeString(market, "base")
    var quoteId interface{} = this.SafeString(market, "quote")
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var active interface{} = this.SafeBool(market, "active", true)
    var minPriceIncrement interface{} = this.SafeString(market, "minPriceIncrement")
    var minSizeIncrement interface{} = this.SafeString(market, "minSizeIncrement")
    var minOrderSize interface{} = this.SafeString(market, "minOrderSize")
    var maxOrderSize interface{} = this.SafeString(market, "maxOrderSize")
    var contractSize interface{} = this.SafeString(market, "contractSize", "1")
    // Detect market type from data
    var futures interface{} = this.SafeBool(market, "futures", false)
    var typeVar interface{} = Ternary(IsTrue(futures), "swap", "spot")
    var spot interface{} =     (IsEqual(typeVar, "spot"))
    var swap interface{} =     (IsEqual(typeVar, "swap"))
    var symbol interface{} = nil
    var settle interface{} = nil
    var settleId interface{} = nil
    if IsTrue(spot) {
        // SPOT: BTC/USDT
        symbol = Add(Add(base, "/"), quote)
        settle = nil
        settleId = nil
    } else {
        // FUTURES: BTC/USDT:USDT
        symbol = Add(Add(Add(Add(base, "/"), quote), ":"), quote)
        settle = quote
        settleId = quoteId
    }
    return map[string]interface{} {
        "id": id,
        "symbol": symbol,
        "base": base,
        "quote": quote,
        "settle": settle,
        "baseId": baseId,
        "quoteId": quoteId,
        "settleId": settleId,
        "type": typeVar,
        "spot": spot,
        "margin": false,
        "swap": swap,
        "future": false,
        "option": false,
        "active": active,
        "contract": swap,
        "linear": Ternary(IsTrue(swap), true, nil),
        "inverse": Ternary(IsTrue(swap), false, nil),
        "contractSize": Ternary(IsTrue(swap), this.ParseNumber(contractSize), nil),
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "amount": this.ParseNumber(minSizeIncrement),
            "price": this.ParseNumber(minPriceIncrement),
        },
        "limits": map[string]interface{} {
            "leverage": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "amount": map[string]interface{} {
                "min": this.ParseNumber(minOrderSize),
                "max": this.ParseNumber(maxOrderSize),
            },
            "price": map[string]interface{} {
                "min": this.ParseNumber(minPriceIncrement),
                "max": nil,
            },
            "cost": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
        },
        "created": nil,
        "info": market,
    }
}
/**
 * @method
 * @name btse#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#market-summary
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *BtseCore) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes4418 := (<-this.LoadMarkets())
            PanicOnError(retRes4418)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var response interface{} = nil
            if IsTrue(GetValue(market, "spot")) {
                
            response = (<-this.PublicSpotGetApiV32MarketSummary(this.Extend(request, params)))
                    PanicOnError(response)
            } else {
                
            response = (<-this.PublicGetApiV23MarketSummary(this.Extend(request, params)))
                    PanicOnError(response)
            }
            var ticker interface{} = this.SafeDict(response, 0)
        
            ch <- this.ParseTicker(ticker, market)
            return nil
        
            }()
            return ch
        }
func  (this *BtseCore) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var last interface{} = this.SafeString(ticker, "last")
    var percentage interface{} = this.SafeString(ticker, "percentageChange")
    var baseVolume interface{} = this.SafeString(ticker, "volume")
    var high interface{} = this.SafeString(ticker, "high24Hr")
    var low interface{} = this.SafeString(ticker, "low24Hr")
    var bid interface{} = this.SafeString(ticker, "highestBid")
    var ask interface{} = this.SafeString(ticker, "lowestAsk")
    var size interface{} = this.SafeString(ticker, "size")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": nil,
        "datetime": nil,
        "high": high,
        "low": low,
        "bid": bid,
        "bidVolume": nil,
        "ask": ask,
        "askVolume": nil,
        "vwap": nil,
        "open": nil,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": percentage,
        "average": nil,
        "baseVolume": baseVolume,
        "quoteVolume": size,
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name btse#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#orderbook
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.group] orderbook grouping level (0-8)
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *BtseCore) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes5038 := (<-this.LoadMarkets())
            PanicOnError(retRes5038)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var response interface{} = nil
            if IsTrue(GetValue(market, "spot")) {
                
            response = (<-this.PublicSpotGetApiV32OrderbookL2(this.Extend(request, params)))
                    PanicOnError(response)
            } else {
                
            response = (<-this.PublicGetApiV23Orderbook(this.Extend(request, params)))
                    PanicOnError(response)
            }
            var timestamp interface{} = this.SafeInteger(response, "timestamp")
        
            ch <- this.ParseOrderBook(response, symbol, timestamp, "buyQuote", "sellQuote", "price", "size")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btse#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#trades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest trade to fetch
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *BtseCore) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes5318 := (<-this.LoadMarkets())
            PanicOnError(retRes5318)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "count": Ternary(IsTrue(!IsEqual(limit, nil)), limit, 100),
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            var until interface{} = this.SafeInteger(params, "until")
            if IsTrue(!IsEqual(until, nil)) {
                params = this.Omit(params, "until")
                AddElementToObject(request, "endTime", until)
            }
            var response interface{} = nil
            if IsTrue(GetValue(market, "spot")) {
                
            response = (<-this.PublicSpotGetApiV32Trades(this.Extend(request, params)))
                    PanicOnError(response)
            } else {
                
            response = (<-this.PublicGetApiV23Trades(this.Extend(request, params)))
                    PanicOnError(response)
            }
        
            ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *BtseCore) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(trade, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var timestamp interface{} = this.SafeInteger(trade, "timestamp")
    var side interface{} = this.SafeStringLower(trade, "side")
    var priceString interface{} = this.SafeString2(trade, "filledPrice", "price")
    var amountString interface{} = this.SafeString2(trade, "filledSize", "size")
    var id interface{} = this.SafeString2(trade, "tradeId", "serialId")
    var orderId interface{} = this.SafeString(trade, "orderId")
    var feeAmount interface{} = this.SafeString(trade, "feeAmount")
    var feeCurrency interface{} = this.SafeString(trade, "feeCurrency")
    var fee interface{} = Ternary(IsTrue((!IsEqual(feeAmount, nil))), map[string]interface{} {
    "cost": feeAmount,
    "currency": this.SafeCurrencyCode(feeCurrency),
}, nil)
    var costString interface{} = this.SafeString(trade, "total")
    return this.SafeTrade(map[string]interface{} {
        "id": id,
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "type": nil,
        "side": side,
        "order": orderId,
        "takerOrMaker": nil,
        "price": priceString,
        "amount": amountString,
        "cost": costString,
        "fee": fee,
    }, market)
}
/**
 * @method
 * @name btse#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, close price, and the volume of a market
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#ohlcv
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest candle to fetch
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *BtseCore) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes6018 := (<-this.LoadMarkets())
            PanicOnError(retRes6018)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "resolution": this.SafeString(this.Timeframes, timeframe, timeframe),
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start", since)
            }
            var until interface{} = this.SafeInteger(params, "until")
            if IsTrue(!IsEqual(until, nil)) {
                params = this.Omit(params, "until")
                AddElementToObject(request, "end", until)
            }
            var response interface{} = nil
            if IsTrue(GetValue(market, "spot")) {
                
            response = (<-this.PublicSpotGetApiV32Ohlcv(this.Extend(request, params)))
                    PanicOnError(response)
            } else {
                
            response = (<-this.PublicGetApiV23Ohlcv(this.Extend(request, params)))
                    PanicOnError(response)
            }
        
            ch <- this.ParseOHLCVs(response, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btse#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#wallet
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.wallet] wallet name, defaults to 'CROSS@'
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *BtseCore) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes6348 := (<-this.LoadMarkets())
            PanicOnError(retRes6348)
            var wallet interface{} = this.SafeString(params, "wallet", "CROSS@")
            var request interface{} = map[string]interface{} {
                "wallet": wallet,
            }
        
            response:= (<-this.PrivateGetApiV23UserWallet(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
func  (this *BtseCore) ParseBalance(response interface{}) interface{}  {
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    var wallets interface{} = this.SafeList(response, 0, []interface{}{})
    if IsTrue(IsEqual(GetArrayLength(wallets), 0)) {
        return this.SafeBalance(result)
    }
    var wallet interface{} = this.SafeDict(response, 0)
    var assets interface{} = this.SafeList(wallet, "assets", []interface{}{})
    for i := 0; IsLessThan(i, GetArrayLength(assets)); i++ {
        var asset interface{} = GetValue(assets, i)
        var currencyId interface{} = this.SafeString(asset, "currency")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        AddElementToObject(account, "total", this.SafeString(asset, "balance"))
        AddElementToObject(result, code, account)
    }
    var availableBalance interface{} = this.SafeString(wallet, "availableBalance")
    var marginBalance interface{} = this.SafeString(wallet, "marginBalance")
    if IsTrue(IsTrue(!IsEqual(availableBalance, nil)) || IsTrue(!IsEqual(marginBalance, nil))) {
        AddElementToObject(result, "free", availableBalance)
        AddElementToObject(result, "used", marginBalance)
        AddElementToObject(result, "total", this.SafeString(wallet, "totalValue"))
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name btse#createOrder
 * @description create a trade order
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much you want to trade in units of the base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.timeInForce] 'GTC', 'IOC', 'FOK', or 'PO'
 * @param {bool} [params.postOnly] true or false
 * @param {bool} [params.reduceOnly] true or false
 * @param {float} [params.triggerPrice] price to trigger stop orders
 * @param {float} [params.stopPrice] price for OCO orders
 * @param {float} [params.takeProfitPrice] take profit trigger price
 * @param {float} [params.stopLossPrice] stop loss trigger price
 * @param {string} [params.clOrderID] client order ID
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *BtseCore) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes6938 := (<-this.LoadMarkets())
            PanicOnError(retRes6938)
            var market interface{} = this.Market(symbol)
            var uppercaseType interface{} = ToUpper(typeVar)
            var uppercaseSide interface{} = ToUpper(side)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "side": uppercaseSide,
                "type": uppercaseType,
                "size": this.AmountToPrecision(symbol, amount),
            }
            if IsTrue(IsEqual(uppercaseType, "LIMIT")) {
                if IsTrue(IsEqual(price, nil)) {
                    panic(InvalidOrder(Add(this.Id, " createOrder() requires a price argument for limit orders")))
                }
                AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
            }
            var timeInForce interface{} = this.SafeString(params, "timeInForce")
            if IsTrue(!IsEqual(timeInForce, nil)) {
                AddElementToObject(request, "time_in_force", timeInForce)
            }
            var postOnly interface{} = this.SafeBool(params, "postOnly")
            if IsTrue(!IsEqual(postOnly, nil)) {
                AddElementToObject(request, "postOnly", postOnly)
            }
            var reduceOnly interface{} = this.SafeBool(params, "reduceOnly")
            if IsTrue(!IsEqual(reduceOnly, nil)) {
                AddElementToObject(request, "reduceOnly", reduceOnly)
            }
            var triggerPrice interface{} = this.SafeString(params, "triggerPrice")
            if IsTrue(!IsEqual(triggerPrice, nil)) {
                AddElementToObject(request, "triggerPrice", this.PriceToPrecision(symbol, triggerPrice))
            }
            var stopPrice interface{} = this.SafeString(params, "stopPrice")
            if IsTrue(!IsEqual(stopPrice, nil)) {
                AddElementToObject(request, "stopPrice", this.PriceToPrecision(symbol, stopPrice))
            }
            var takeProfitPrice interface{} = this.SafeString(params, "takeProfitPrice")
            if IsTrue(!IsEqual(takeProfitPrice, nil)) {
                AddElementToObject(request, "takeProfitPrice", this.PriceToPrecision(symbol, takeProfitPrice))
            }
            var stopLossPrice interface{} = this.SafeString(params, "stopLossPrice")
            if IsTrue(!IsEqual(stopLossPrice, nil)) {
                AddElementToObject(request, "stopLossPrice", this.PriceToPrecision(symbol, stopLossPrice))
            }
            var clientOrderId interface{} = this.SafeString(params, "clOrderID")
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "clOrderID", clientOrderId)
            }
            params = this.Omit(params, []interface{}{"timeInForce", "postOnly", "reduceOnly", "triggerPrice", "stopPrice", "takeProfitPrice", "stopLossPrice", "clOrderID"})
        
            response:= (<-this.PrivatePostApiV23Order(this.Extend(request, params)))
            PanicOnError(response)
            var order interface{} = Ternary(IsTrue(IsArray(response)), GetValue(response, 0), response)
        
            ch <- this.ParseOrder(order, market)
            return nil
        
            }()
            return ch
        }
func  (this *BtseCore) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(order, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var orderId interface{} = this.SafeString(order, "orderID")
    var clientOrderId interface{} = this.SafeString(order, "clOrderID")
    var timestamp interface{} = this.SafeInteger(order, "timestamp")
    var side interface{} = this.SafeStringLower(order, "side")
    var typeVar interface{} = this.SafeStringLower(order, "type")
    var price interface{} = this.SafeString(order, "price")
    var amount interface{} = this.SafeString(order, "originalOrderSize")
    var filled interface{} = this.SafeString(order, "filledSize")
    var remaining interface{} = this.SafeString(order, "currentOrderSize")
    var status interface{} = this.ParseOrderStatus(this.SafeString(order, "status"))
    var average interface{} = this.SafeString(order, "avgFillPrice")
    var timeInForce interface{} = this.SafeString(order, "timeInForce")
    var postOnly interface{} = this.SafeBool(order, "postOnly")
    var reduceOnly interface{} = this.SafeBool(order, "reduceOnly")
    var triggerPrice interface{} = this.SafeString(order, "triggerPrice")
    var stopPrice interface{} = this.SafeString(order, "stopPrice")
    return this.SafeOrder(map[string]interface{} {
        "id": orderId,
        "clientOrderId": clientOrderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "status": status,
        "symbol": symbol,
        "type": typeVar,
        "timeInForce": timeInForce,
        "postOnly": postOnly,
        "reduceOnly": reduceOnly,
        "side": side,
        "price": price,
        "stopPrice": stopPrice,
        "triggerPrice": triggerPrice,
        "amount": amount,
        "filled": filled,
        "remaining": remaining,
        "cost": nil,
        "average": average,
        "trades": nil,
        "fee": nil,
        "info": order,
    }, market)
}
func  (this *BtseCore) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "1": "open",
        "2": "open",
        "4": "closed",
        "5": "canceled",
        "6": "open",
        "8": "canceled",
        "9": "canceled",
        "10": "canceled",
        "15": "rejected",
    }
    return this.SafeString(statuses, status, status)
}
/**
 * @method
 * @name btse#cancelOrder
 * @description cancels an open order
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#order-2
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.clOrderID] client order id
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *BtseCore) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(InvalidOrder(Add(this.Id, " cancelOrder() requires a symbol argument")))
            }
        
            retRes8238 := (<-this.LoadMarkets())
            PanicOnError(retRes8238)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var clientOrderId interface{} = this.SafeString(params, "clOrderID")
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "clOrderID", clientOrderId)
                params = this.Omit(params, "clOrderID")
            } else {
                AddElementToObject(request, "orderID", id)
            }
        
            response:= (<-this.PrivateDeleteApiV23Order(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btse#cancelAllOrders
 * @description cancel all open orders in a market
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#order-2
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *BtseCore) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(InvalidOrder(Add(this.Id, " cancelAllOrders() requires a symbol argument")))
            }
        
            retRes8528 := (<-this.LoadMarkets())
            PanicOnError(retRes8528)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PrivateDeleteApiV23Order(this.Extend(request, params)))
            PanicOnError(response)
            if IsTrue(IsArray(response)) {
        
                ch <- this.ParseOrders(response, market)
                return nil
            }
        
            ch <- []interface{}{this.ParseOrder(response, market)}
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btse#editOrder
 * @description edit a trade order
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#order-1
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market to edit the order in
 * @param {string} type not used by btse editOrder
 * @param {string} side not used by btse editOrder
 * @param {float} [amount] how much you want to trade in units of the base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.triggerPrice] price to trigger stop orders
 * @param {string} [params.clOrderID] client order id
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *BtseCore) EditOrder(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    amount := GetArg(optionalArgs, 0, nil)
            _ = amount
            price := GetArg(optionalArgs, 1, nil)
            _ = price
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes8818 := (<-this.LoadMarkets())
            PanicOnError(retRes8818)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var clientOrderId interface{} = this.SafeString(params, "clOrderID")
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "clOrderID", clientOrderId)
                params = this.Omit(params, "clOrderID")
            } else {
                AddElementToObject(request, "orderID", id)
            }
            var triggerPrice interface{} = this.SafeString(params, "triggerPrice")
            if IsTrue(IsTrue(IsTrue(!IsEqual(price, nil)) && IsTrue(!IsEqual(amount, nil))) && IsTrue(!IsEqual(triggerPrice, nil))) {
                AddElementToObject(request, "type", "ALL")
                AddElementToObject(request, "orderPrice", this.PriceToPrecision(symbol, price))
                AddElementToObject(request, "orderSize", this.AmountToPrecision(symbol, amount))
                AddElementToObject(request, "triggerPrice", this.PriceToPrecision(symbol, triggerPrice))
                params = this.Omit(params, "triggerPrice")
            } else if IsTrue(IsTrue(!IsEqual(price, nil)) && IsTrue(!IsEqual(amount, nil))) {
                AddElementToObject(request, "type", "ALL")
                AddElementToObject(request, "orderPrice", this.PriceToPrecision(symbol, price))
                AddElementToObject(request, "orderSize", this.AmountToPrecision(symbol, amount))
            } else if IsTrue(!IsEqual(price, nil)) {
                AddElementToObject(request, "type", "PRICE")
                AddElementToObject(request, "value", this.PriceToPrecision(symbol, price))
            } else if IsTrue(!IsEqual(amount, nil)) {
                AddElementToObject(request, "type", "SIZE")
                AddElementToObject(request, "value", this.AmountToPrecision(symbol, amount))
            } else if IsTrue(!IsEqual(triggerPrice, nil)) {
                AddElementToObject(request, "type", "TRIGGERPRICE")
                AddElementToObject(request, "value", this.PriceToPrecision(symbol, triggerPrice))
                params = this.Omit(params, "triggerPrice")
            } else {
                panic(InvalidOrder(Add(this.Id, " editOrder() requires a price, amount, or triggerPrice argument")))
            }
        
            response:= (<-this.PrivatePutApiV23Order(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btse#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#query-open-orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] not used by btse fetchOpenOrders
 * @param {int} [limit] not used by btse fetchOpenOrders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *BtseCore) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes9338 := (<-this.LoadMarkets())
            PanicOnError(retRes9338)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
        
            response:= (<-this.PrivateGetApiV23UserOpenOrders(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrders(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btse#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#query-open-orders
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.clOrderID] client order id
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *BtseCore) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes9568 := (<-this.LoadMarkets())
            PanicOnError(retRes9568)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            var clientOrderId interface{} = this.SafeString(params, "clOrderID")
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "clOrderID", clientOrderId)
                params = this.Omit(params, "clOrderID")
            } else {
                AddElementToObject(request, "orderID", id)
            }
        
            response:= (<-this.PrivateGetApiV23UserOpenOrders(this.Extend(request, params)))
            PanicOnError(response)
            if IsTrue(IsTrue(IsArray(response)) && IsTrue(IsGreaterThan(GetArrayLength(response), 0))) {
        
                ch <- this.ParseOrder(GetValue(response, 0), market)
                return nil
            }
            panic(OrderNotFound(Add(Add(this.Id, " fetchOrder() could not find order "), id)))
        
            }()
            return ch
        }
/**
 * @method
 * @name btse#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#query-trades-fills
 * @param {string} symbol unified market symbol
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum number of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest trade to fetch
 * @param {string} [params.orderID] filter trades by order ID
 * @param {string} [params.clOrderID] filter trades by client order ID
 * @param {bool} [params.includeOld] include trades older than 7 days
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *BtseCore) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes9938 := (<-this.LoadMarkets())
            PanicOnError(retRes9938)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            var until interface{} = this.SafeInteger(params, "until")
            if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "endTime", until)
                params = this.Omit(params, "until")
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "count", limit)
            }
            var orderID interface{} = this.SafeString(params, "orderID")
            if IsTrue(!IsEqual(orderID, nil)) {
                AddElementToObject(request, "orderID", orderID)
                params = this.Omit(params, "orderID")
            }
            var clOrderID interface{} = this.SafeString(params, "clOrderID")
            if IsTrue(!IsEqual(clOrderID, nil)) {
                AddElementToObject(request, "clOrderID", clOrderID)
                params = this.Omit(params, "clOrderID")
            }
            var includeOld interface{} = this.SafeBool(params, "includeOld")
            if IsTrue(!IsEqual(includeOld, nil)) {
                AddElementToObject(request, "includeOld", includeOld)
                params = this.Omit(params, "includeOld")
            }
        
            response:= (<-this.PrivateGetApiV23UserTradeHistory(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btse#fetchPositions
 * @description fetch all open positions
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#query-position
 * @param {string[]} [symbols] list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *BtseCore) FetchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes10408 := (<-this.LoadMarkets())
            PanicOnError(retRes10408)
        
            response:= (<-this.PrivateGetApiV23UserPositions(params))
            PanicOnError(response)
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                var position interface{} = GetValue(response, i)
                var parsed interface{} = this.ParsePosition(position)
                AppendToArray(&result, parsed)
            }
        
            ch <- this.FilterByArrayPositions(result, "symbol", symbols, false)
            return nil
        
            }()
            return ch
        }
func  (this *BtseCore) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(position, "symbol")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = GetValue(market, "symbol")
    var sideString interface{} = this.SafeString(position, "side")
    var side interface{} = Ternary(IsTrue((IsEqual(sideString, "BUY"))), "long", "short")
    var contractsString interface{} = this.SafeString(position, "size")
    var entryPriceString interface{} = this.SafeString(position, "entryPrice")
    var markPriceString interface{} = this.SafeString(position, "markPrice")
    var unrealizedPnl interface{} = this.SafeString(position, "unrealizedProfitLoss")
    var liquidationPrice interface{} = this.SafeString(position, "liquidationPrice")
    var notional interface{} = this.SafeString(position, "orderValue")
    var marginType interface{} = this.SafeInteger(position, "marginType")
    var marginMode interface{} = Ternary(IsTrue((IsEqual(marginType, 91))), "cross", "isolated")
    return this.SafePosition(map[string]interface{} {
        "info": position,
        "id": this.SafeString(position, "positionId"),
        "symbol": symbol,
        "timestamp": nil,
        "datetime": nil,
        "initialMargin": nil,
        "initialMarginPercentage": nil,
        "maintenanceMargin": this.SafeString(position, "totalMaintenanceMargin"),
        "maintenanceMarginPercentage": nil,
        "entryPrice": entryPriceString,
        "notional": notional,
        "leverage": nil,
        "unrealizedPnl": unrealizedPnl,
        "contracts": contractsString,
        "contractSize": GetValue(market, "contractSize"),
        "marginRatio": nil,
        "liquidationPrice": liquidationPrice,
        "markPrice": markPriceString,
        "collateral": nil,
        "marginMode": marginMode,
        "side": side,
        "percentage": nil,
    })
}
/**
 * @method
 * @name btse#setLeverage
 * @description set the level of leverage for a market
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#set-leverage
 * @param {float} leverage the rate of leverage
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} response from the exchange
 */
func  (this *BtseCore) SetLeverage(leverage interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(InvalidOrder(Add(this.Id, " setLeverage() requires a symbol argument")))
            }
        
            retRes11058 := (<-this.LoadMarkets())
            PanicOnError(retRes11058)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "leverage": leverage,
            }
        
            response:= (<-this.PrivatePostApiV23Leverage(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- response
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btse#transfer
 * @description transfer currency internally between wallets on the same account
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#wallet-transfer
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount account to transfer from
 * @param {string} toAccount account to transfer to
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *BtseCore) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes11288 := (<-this.LoadMarkets())
            PanicOnError(retRes11288)
            var currency interface{} = this.Currency(code)
            var accountTypes interface{} = map[string]interface{} {
                "spot": "SPOT",
                "cross": "CROSS",
                "isolated": "ISOLATED",
            }
            var fromType interface{} = this.SafeString(accountTypes, fromAccount, fromAccount)
            var toType interface{} = this.SafeString(accountTypes, toAccount, toAccount)
            var request interface{} = map[string]interface{} {
                "walletSrcType": fromType,
                "walletDestType": toType,
                "apiWallets": []interface{}{map[string]interface{} {
            "currency": GetValue(currency, "id"),
            "balance": this.CurrencyToPrecision(code, amount),
        }},
            }
        
            response:= (<-this.PrivatePostApiV23UserWalletTransfer(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseTransfer(response, currency)
            return nil
        
            }()
            return ch
        }
func  (this *BtseCore) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    return map[string]interface{} {
        "info": transfer,
        "id": this.SafeString(transfer, "transferId"),
        "timestamp": this.SafeInteger(transfer, "timestamp"),
        "datetime": this.SafeString(transfer, "datetime"),
        "currency": this.SafeCurrencyCode(nil, currency),
        "amount": nil,
        "fromAccount": nil,
        "toAccount": nil,
        "status": nil,
    }
}


func (this *BtseCore) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.DerivedExchange = this
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}

package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type BtseCore struct {
	*ccxt.BtseCore
	base *ccxt.BtseCore
}

func NewBtseCore() *BtseCore {
    p := &BtseCore{}
	base := &ccxt.BtseCore{}
	p.base = base
	p.BtseCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *BtseCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "createOrderWs": false,
            "editOrderWs": false,
            "cancelOrderWs": false,
            "cancelAllOrdersWs": false,
            "watchBalance": true,
            "watchMyTrades": true,
            "watchOHLCV": true,
            "watchOHLCVForSymbols": true,
            "watchOrderBook": true,
            "watchOrderBookForSymbols": true,
            "watchOrders": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchTrades": true,
            "watchTradesForSymbols": true,
            "watchPositions": true,
            "unWatchTicker": true,
            "unWatchTickers": true,
            "unWatchOHLCV": true,
            "unWatchOHLCVForSymbols": true,
            "unWatchOrderBook": true,
            "unWatchOrderBookForSymbols": true,
            "unWatchTrades": true,
            "unWatchTradesForSymbols": true,
            "unWatchMyTrades": true,
            "unWatchOrders": true,
            "unWatchPositions": true,
            "unWatchBalance": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": map[string]interface{} {
                    "public": "wss://ws.btse.com/ws/futures",
                    "orderbook": "wss://ws.btse.com/ws/oss/futures",
                    "private": "wss://ws.btse.com/ws/futures",
                    "publicSpot": "wss://ws.btse.com/ws/spot",
                    "orderbookSpot": "wss://ws.btse.com/ws/oss/spot",
                    "privateSpot": "wss://ws.btse.com/ws/spot",
                },
            },
            "test": map[string]interface{} {
                "ws": map[string]interface{} {
                    "public": "wss://testws.btse.io/ws/futures",
                    "orderbook": "wss://testws.btse.io/ws/oss/futures",
                    "private": "wss://testws.btse.io/ws/futures",
                    "publicSpot": "wss://testws.btse.io/ws/spot",
                    "orderbookSpot": "wss://testws.btse.io/ws/oss/spot",
                    "privateSpot": "wss://testws.btse.io/ws/spot",
                },
            },
        },
        "options": map[string]interface{} {
            "watchOrderBook": map[string]interface{} {
                "grouping": "0",
                "type": "snapshotL2",
            },
            "watchPositions": map[string]interface{} {
                "fetchPositionsSnapshot": true,
                "awaitPositionsSnapshot": true,
            },
            "requestId": 0,
        },
        "streaming": map[string]interface{} {},
    })
}
func  (this *BtseCore) RequestId() interface{}  {
    var requestId interface{} = this.Sum(this.SafeInteger(this.Options, "requestId", 0), 1)
    ccxt.AddElementToObject(this.Options, "requestId", requestId)
    return requestId
}
func  (this *BtseCore) GetUrl(optionalArgs ...interface{}) interface{}  {
    isPrivate := ccxt.GetArg(optionalArgs, 0, false)
    _ = isPrivate
    isOrderbook := ccxt.GetArg(optionalArgs, 1, false)
    _ = isOrderbook
    market := ccxt.GetArg(optionalArgs, 2, nil)
    _ = market
    var urls interface{} = this.SafeValue(this.Urls, ccxt.GetValue(this.Options, "defaultType"), ccxt.GetValue(this.Urls, "api"))
    var ws interface{} = this.SafeValue(urls, "ws", map[string]interface{} {})
    // Determine if this is a SPOT market
    var isSpot interface{} = ccxt.IsTrue((!ccxt.IsEqual(market, nil))) && ccxt.IsTrue(this.SafeValue(market, "spot", false))
    // Select appropriate endpoint based on market type
    if ccxt.IsTrue(isOrderbook) {
        return this.SafeString(ws, ccxt.Ternary(ccxt.IsTrue(isSpot), "orderbookSpot", "orderbook"))
    } else if ccxt.IsTrue(isPrivate) {
        return this.SafeString(ws, ccxt.Ternary(ccxt.IsTrue(isSpot), "privateSpot", "private"))
    } else {
        return this.SafeString(ws, ccxt.Ternary(ccxt.IsTrue(isSpot), "publicSpot", "public"))
    }
}
func  (this *BtseCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var url interface{} = this.GetUrl(true)
            var client interface{} = this.Client(url)
            var messageHash interface{} = "authenticated"
            var future interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            if ccxt.IsTrue(ccxt.IsEqual(future, nil)) {
                this.CheckRequiredCredentials()
                var nonce interface{} = this.Nonce()
                var path interface{} = "/ws/futures"
                var auth interface{} = ccxt.Add(path, ccxt.ToString(nonce))
                var signature interface{} = this.Hmac(this.Encode(auth), this.Encode(this.Secret), ccxt.Sha384, "hex")
                var request interface{} = map[string]interface{} {
                    "op": "authKeyExpires",
                    "args": []interface{}{this.ApiKey, nonce, signature},
                }
                
            future = (<-this.Watch(url, messageHash, request, messageHash))
                    ccxt.PanicOnError(future)
            }
        
            ch <- future
            return nil
        
            }()
            return ch
        }
func  (this *BtseCore) Ping(client interface{}) interface{}  {
    return map[string]interface{} {
        "op": "ping",
    }
}
func  (this *BtseCore) HandlePong(client interface{}, message interface{}) interface{}  {
    // Message: { "op": "pong", "timestamp": 1680751558529 }
    client.(ccxt.ClientInterface).SetLastPong(this.Milliseconds())
}
func  (this *BtseCore) HandleMessage(client interface{}, message interface{}) interface{}  {
    var topic interface{} = this.SafeString(message, "topic")
    var op interface{} = this.SafeString(message, "op")
    // Handle operational messages
    if ccxt.IsTrue(ccxt.IsEqual(op, "pong")) {
        return this.HandlePong(client, message)
    } else if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(op, "subscribe")) || ccxt.IsTrue(ccxt.IsEqual(op, "unsubscribe"))) {
        return this.HandleSubscriptionStatus(client, message)
    } else if ccxt.IsTrue(ccxt.IsEqual(op, "authKeyExpires")) {
        return this.HandleAuthenticationMessage(client, message)
    }
    // Handle data messages by topic
    if ccxt.IsTrue(!ccxt.IsEqual(topic, nil)) {
        if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetIndexOf(topic, "ticker:"), 0)) {
            return this.HandleTicker(client, message)
        } else if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(ccxt.GetIndexOf(topic, "snapshotL1:"), 0)) || ccxt.IsTrue(ccxt.IsEqual(ccxt.GetIndexOf(topic, "snapshotL2:"), 0))) {
            return this.HandleOrderBook(client, message)
        } else if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(topic, "trades")) || ccxt.IsTrue(ccxt.IsEqual(ccxt.GetIndexOf(topic, "trades:"), 0))) || ccxt.IsTrue(ccxt.IsEqual(ccxt.GetIndexOf(topic, "tradeHistoryApi"), 0))) {
            // BTSE FUTURES uses "tradeHistoryApiV3:BTC-PERP"
            // BTSE SPOT uses "tradeHistoryApi:BTC-USD"
            return this.HandleTrades(client, message)
        } else if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetIndexOf(topic, "kline:"), 0)) {
            return this.HandleOHLCV(client, message)
        } else if ccxt.IsTrue(ccxt.IsEqual(topic, "orders")) {
            return this.HandleOrders(client, message)
        } else if ccxt.IsTrue(ccxt.IsEqual(topic, "fills")) {
            return this.HandleMyTrades(client, message)
        } else if ccxt.IsTrue(ccxt.IsEqual(topic, "positionsV3")) {
            return this.HandlePositions(client, message)
        } else if ccxt.IsTrue(ccxt.IsEqual(topic, "wallet")) {
            return this.HandleBalance(client, message)
        } else if ccxt.IsTrue(ccxt.IsEqual(topic, "error")) {
            return this.HandleError(client, message)
        }
    }
}
func  (this *BtseCore) HandleSubscriptionStatus(client interface{}, message interface{}) interface{}  {
    // Handle subscription/unsubscription confirmation
    return message
}
func  (this *BtseCore) HandleAuthenticationMessage(client interface{}, message interface{}) interface{}  {
    var messageHash interface{} = "authenticated"
    var future interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
    if ccxt.IsTrue(!ccxt.IsEqual(future, nil)) {
        future.(*ccxt.Future).Resolve(true)
    }
    return message
}
func  (this *BtseCore) HandleError(client interface{}, message interface{}) interface{}  {
    // ccxt.Error format:
    // {
    //   "topic": "error",
    //   "code": 4001,
    //   "message": "Invalid symbol"
    // }
    var code interface{} = this.SafeInteger(message, "code")
    var errorMessage interface{} = this.SafeString(message, "message")
    if ccxt.IsTrue(!ccxt.IsEqual(code, nil)) {
        if ccxt.IsTrue(ccxt.IsEqual(code, 4001)) {
            panic(ccxt.BadSymbol(errorMessage))
        } else if ccxt.IsTrue(ccxt.IsEqual(code, 4003)) {
            panic(ccxt.AuthenticationError(errorMessage))
        } else if ccxt.IsTrue(ccxt.IsEqual(code, 4004)) {
            panic(ccxt.ExchangeError(errorMessage))
        }
        panic(ccxt.ExchangeError(errorMessage))
    }
    return false
}
/**
 * @method
 * @name btse#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *BtseCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes2268 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2268)
            var market interface{} = this.Market(symbol)
            var url interface{} = this.GetUrl(false, false, market)
            var messageHash interface{} = ccxt.Add("ticker:", symbol)
            var topic interface{} = ccxt.Add("ticker:", ccxt.GetValue(market, "id"))
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": []interface{}{topic},
            }
        
                retRes23515 :=  (<-this.Watch(url, messageHash, request, messageHash))
                ccxt.PanicOnError(retRes23515)
                ch <- retRes23515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btse#watchTickers
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *BtseCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes2488 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2488)
            symbols = this.MarketSymbols(symbols, nil, false)
            var messageHashes interface{} = []interface{}{}
            var topics interface{} = []interface{}{}
            var firstMarket interface{} = nil
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                if ccxt.IsTrue(ccxt.IsEqual(i, 0)) {
                    firstMarket = market
                }
                var topic interface{} = ccxt.Add("ticker:", ccxt.GetValue(market, "id"))
                ccxt.AppendToArray(&topics, topic)
                ccxt.AppendToArray(&messageHashes, ccxt.Add("ticker:", symbol))
            }
            var url interface{} = this.GetUrl(false, false, firstMarket)
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": topics,
            }
        
            ticker:= (<-this.WatchMultiple(url, messageHashes, request, messageHashes))
            ccxt.PanicOnError(ticker)
            if ccxt.IsTrue(this.NewUpdates) {
                var result interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(result, ccxt.GetValue(ticker, "symbol"), ticker)
        
                ch <- result
                return nil
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btse#unWatchTicker
 * @description unwatch a price ticker
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
 * @param {string} symbol unified symbol of the market to unwatch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {any} status
 */
func  (this *BtseCore) UnWatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes28715 :=  (<-this.UnWatchTickers([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes28715)
                ch <- retRes28715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btse#unWatchTickers
 * @description unwatch price tickers
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
 * @param {string[]} symbols unified symbols of the markets to unwatch the tickers for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {any} status
 */
func  (this *BtseCore) UnWatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3008 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3008)
            symbols = this.MarketSymbols(symbols, nil, false)
            var topics interface{} = []interface{}{}
            var firstMarket interface{} = nil
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                if ccxt.IsTrue(ccxt.IsEqual(i, 0)) {
                    firstMarket = market
                }
                var topic interface{} = ccxt.Add("ticker:", ccxt.GetValue(market, "id"))
                ccxt.AppendToArray(&topics, topic)
            }
            var url interface{} = this.GetUrl(false, false, firstMarket)
            var request interface{} = map[string]interface{} {
                "op": "unsubscribe",
                "args": topics,
            }
        
                retRes31815 :=  (<-this.Watch(url, "unsubscribe:ticker", request, "unsubscribe:ticker"))
                ccxt.PanicOnError(retRes31815)
                ch <- retRes31815
                return nil
        
            }()
            return ch
        }
func  (this *BtseCore) HandleTicker(client interface{}, message interface{}) interface{}  {
    //
    // {
    //   "topic": "ticker:BTC-PERP",
    //   "data": {
    //     "symbol": "BTC-PERP",
    //     "last": "28065.0",
    //     "lowestAsk": "28065.0",
    //     "highestBid": "28064.5",
    //     "volume24h": "123456.78",
    //     "high24h": "28500.0",
    //     "low24h": "27500.0",
    //     "timestamp": 1680751558529
    //   }
    // }
    //
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var ticker interface{} = this.ParseTicker(data)
    var symbol interface{} = ccxt.GetValue(ticker, "symbol")
    ccxt.AddElementToObject(this.Tickers, symbol, ticker)
    var messageHash interface{} = ccxt.Add("ticker:", symbol)
    client.(ccxt.ClientInterface).Resolve(ticker, messageHash)
    return message
}
/**
 * @method
 * @name btse#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.grouping] orderbook grouping level, '0', '1', '2', '3' (default '0')
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *BtseCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3588 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3588)
            var market interface{} = this.Market(symbol)
            var url interface{} = this.GetUrl(false, true, market) // Use orderbook URL
            var options interface{} = this.SafeValue(this.Options, "watchOrderBook", map[string]interface{} {})
            var grouping interface{} = this.SafeString2(params, "grouping", "group", this.SafeString(options, "grouping", "0"))
            var typeVar interface{} = this.SafeString(options, "type", "snapshotL2")
            var messageHash interface{} = ccxt.Add("orderbook:", symbol)
            var topic interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(typeVar, ":"), ccxt.GetValue(market, "id")), "_"), grouping)
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": []interface{}{topic},
            }
        
            orderbook:= (<-this.Watch(url, messageHash, request, messageHash))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btse#watchOrderBookForSymbols
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
 * @param {string[]} symbols unified array of symbols
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.grouping] orderbook grouping level, '0', '1', '2', '3' (default '0')
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *BtseCore) WatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3868 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3868)
            var firstMarket interface{} = this.Market(ccxt.GetValue(symbols, 0))
            var url interface{} = this.GetUrl(false, true, firstMarket)
            var options interface{} = this.SafeValue(this.Options, "watchOrderBook", map[string]interface{} {})
            var grouping interface{} = this.SafeString2(params, "grouping", "group", this.SafeString(options, "grouping", "0"))
            var typeVar interface{} = this.SafeString(options, "type", "snapshotL2")
            var messageHashes interface{} = []interface{}{}
            var topics interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                var topic interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(typeVar, ":"), ccxt.GetValue(market, "id")), "_"), grouping)
                ccxt.AppendToArray(&topics, topic)
                ccxt.AppendToArray(&messageHashes, ccxt.Add("orderbook:", symbol))
            }
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": topics,
            }
        
            orderbook:= (<-this.WatchMultiple(url, messageHashes, request, messageHashes))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btse#unWatchOrderBook
 * @description unwatch orderbook
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
 * @param {string} symbol unified symbol of the market to unwatch the orderbook for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {any} status
 */
func  (this *BtseCore) UnWatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes41915 :=  (<-this.UnWatchOrderBookForSymbols([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes41915)
                ch <- retRes41915
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btse#unWatchOrderBookForSymbols
 * @description unwatch orderbook for symbols
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
 * @param {string[]} symbols unified symbols of the markets to unwatch the orderbooks for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {any} status
 */
func  (this *BtseCore) UnWatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes4328 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4328)
            var options interface{} = this.SafeValue(this.Options, "watchOrderBook", map[string]interface{} {})
            var grouping interface{} = this.SafeString2(params, "grouping", "group", this.SafeString(options, "grouping", "0"))
            var typeVar interface{} = this.SafeString(options, "type", "snapshotL2")
            var topics interface{} = []interface{}{}
            var firstMarket interface{} = nil
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                if ccxt.IsTrue(ccxt.IsEqual(i, 0)) {
                    firstMarket = market
                }
                var topic interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(typeVar, ":"), ccxt.GetValue(market, "id")), "_"), grouping)
                ccxt.AppendToArray(&topics, topic)
            }
            var url interface{} = this.GetUrl(false, true, firstMarket)
            var request interface{} = map[string]interface{} {
                "op": "unsubscribe",
                "args": topics,
            }
        
                retRes45215 :=  (<-this.Watch(url, "unsubscribe:orderbook", request, "unsubscribe:orderbook"))
                ccxt.PanicOnError(retRes45215)
                ch <- retRes45215
                return nil
        
            }()
            return ch
        }
func  (this *BtseCore) HandleOrderBook(client interface{}, message interface{}) interface{}  {
    //
    // Snapshot:
    // {
    //   "topic": "snapshotL2:BTC-PERP_0",
    //   "data": {
    //     "bids": [["28064.5", "1250"], ["28064.0", "850"]],
    //     "asks": [["28065.0", "1015"], ["28065.5", "720"]],
    //     "type": "snapshot",
    //     "symbol": "BTC-PERP",
    //     "timestamp": 1680751558529,
    //     "prevSeqNum": 0,
    //     "seqNum": 12345
    //   }
    // }
    //
    // Delta:
    // {
    //   "topic": "snapshotL2:BTC-PERP_0",
    //   "data": {
    //     "bids": [["28064.5", "1300"]],
    //     "asks": [],
    //     "type": "delta",
    //     "symbol": "BTC-PERP",
    //     "timestamp": 1680751559000,
    //     "prevSeqNum": 12345,
    //     "seqNum": 12346
    //   }
    // }
    //
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "symbol")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var typeVar interface{} = this.SafeString(data, "type")
    var timestamp interface{} = this.SafeInteger(data, "timestamp")
    var seqNum interface{} = this.SafeInteger(data, "seqNum")
    if ccxt.IsTrue(ccxt.IsEqual(typeVar, "snapshot")) {
        var snapshot interface{} = this.ParseOrderBook(data, symbol, timestamp)
        ccxt.AddElementToObject(snapshot, "nonce", seqNum)
        var orderbook interface{} = this.SafeValue(this.Orderbooks, symbol)
        if ccxt.IsTrue(ccxt.IsEqual(orderbook, nil)) {
            orderbook = this.OrderBook(snapshot)
        } else {
            orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
        }
        ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
    } else if ccxt.IsTrue(ccxt.IsEqual(typeVar, "delta")) {
        var orderbook interface{} = this.SafeValue(this.Orderbooks, symbol)
        if ccxt.IsTrue(ccxt.IsEqual(orderbook, nil)) {
            // Wait for snapshot
            return message
        }
        var bids interface{} = this.SafeList(data, "bids", []interface{}{})
        var asks interface{} = this.SafeList(data, "asks", []interface{}{})
        this.HandleDeltas(ccxt.GetValue(orderbook, "bids"), bids)
        this.HandleDeltas(ccxt.GetValue(orderbook, "asks"), asks)
        ccxt.AddElementToObject(orderbook, "nonce", seqNum)
        ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
        ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
        ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
    }
    var messageHash interface{} = ccxt.Add("orderbook:", symbol)
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Orderbooks, symbol), messageHash)
    return message
}
func  (this *BtseCore) HandleDeltas(bookSide interface{}, deltas interface{})  {
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(deltas)); i++ {
        var delta interface{} = ccxt.GetValue(deltas, i)
        var price interface{} = this.SafeFloat(delta, 0)
        var amount interface{} = this.SafeFloat(delta, 1)
        bookSide.(ccxt.IOrderBookSide).Store(price, amount)
    }
}
/**
 * @method
 * @name btse#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *BtseCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes5438 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5438)
            var market interface{} = this.Market(symbol)
            var url interface{} = this.GetUrl(false, false, market)
            var messageHash interface{} = ccxt.Add("trades:", symbol)
            // SPOT uses 'tradeHistoryApi:', FUTURES uses 'tradeHistoryApiV3:'
            var topicPrefix interface{} = ccxt.Ternary(ccxt.IsTrue(ccxt.GetValue(market, "spot")), "tradeHistoryApi:", "tradeHistoryApiV3:")
            var topic interface{} = ccxt.Add(topicPrefix, ccxt.GetValue(market, "id"))
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": []interface{}{topic},
            }
        
            trades:= (<-this.Watch(url, messageHash, request, messageHash))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btse#watchTradesForSymbols
 * @description get the list of most recent trades for a particular symbol
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
 * @param {string[]} symbols unified symbols of the markets to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *BtseCore) WatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes5738 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5738)
            var messageHashes interface{} = []interface{}{}
            var topics interface{} = []interface{}{}
            var firstMarket interface{} = nil
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                if ccxt.IsTrue(ccxt.IsEqual(i, 0)) {
                    firstMarket = market
                }
                // SPOT uses 'tradeHistoryApi:', FUTURES uses 'tradeHistoryApiV3:'
                var topicPrefix interface{} = ccxt.Ternary(ccxt.IsTrue(ccxt.GetValue(market, "spot")), "tradeHistoryApi:", "tradeHistoryApiV3:")
                var topic interface{} = ccxt.Add(topicPrefix, ccxt.GetValue(market, "id"))
                ccxt.AppendToArray(&topics, topic)
                ccxt.AppendToArray(&messageHashes, ccxt.Add("trades:", symbol))
            }
            var url interface{} = this.GetUrl(false, false, firstMarket)
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": topics,
            }
        
            trades:= (<-this.WatchMultiple(url, messageHashes, request, messageHashes))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                if ccxt.IsTrue(!ccxt.IsEqual(trades, nil)) {
                    var first interface{} = this.SafeValue(trades, 0)
                    var symbol interface{} = this.SafeString(first, "symbol")
                    limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
                }
            }
            if ccxt.IsTrue(ccxt.IsEqual(trades, nil)) {
        
                ch <- []interface{}{}
                return nil
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btse#unWatchTrades
 * @description unwatch trades
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
 * @param {string} symbol unified symbol of the market to unwatch trades for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {any} status
 */
func  (this *BtseCore) UnWatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes61815 :=  (<-this.UnWatchTradesForSymbols([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes61815)
                ch <- retRes61815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btse#unWatchTradesForSymbols
 * @description unwatch trades for symbols
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
 * @param {string[]} symbols unified symbols of the markets to unwatch trades for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {any} status
 */
func  (this *BtseCore) UnWatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes6318 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6318)
            var topics interface{} = []interface{}{}
            var firstMarket interface{} = nil
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                if ccxt.IsTrue(ccxt.IsEqual(i, 0)) {
                    firstMarket = market
                }
                // SPOT uses 'tradeHistoryApi:', FUTURES uses 'tradeHistoryApiV3:'
                var topicPrefix interface{} = ccxt.Ternary(ccxt.IsTrue(ccxt.GetValue(market, "spot")), "tradeHistoryApi:", "tradeHistoryApiV3:")
                var topic interface{} = ccxt.Add(topicPrefix, ccxt.GetValue(market, "id"))
                ccxt.AppendToArray(&topics, topic)
            }
            var url interface{} = this.GetUrl(false, false, firstMarket)
            var request interface{} = map[string]interface{} {
                "op": "unsubscribe",
                "args": topics,
            }
        
                retRes65015 :=  (<-this.Watch(url, "unsubscribe:trades", request, "unsubscribe:trades"))
                ccxt.PanicOnError(retRes65015)
                ch <- retRes65015
                return nil
        
            }()
            return ch
        }
func  (this *BtseCore) HandleTrades(client interface{}, message interface{}) interface{}  {
    //
    // {
    //   "topic": "trades",
    //   "data": [{
    //     "symbol": "BTCPFC",  // Note: BTSE uses different symbols in WS vs REST
    //     "side": "BUY",
    //     "size": "0.5",
    //     "price": "28065.0",
    //     "tradeId": "abc123def",
    //     "timestamp": 1680751558529
    //   }]
    // }
    //
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    // BTSE sends "BTCPFC" for BTC-PERP in WebSocket messages
    // We need to find the correct market by looking at what we have in our markets
    var tradesArray interface{} = []interface{}{}
    var symbolsByMarketId interface{} = map[string]interface{} {}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var rawData interface{} = ccxt.GetValue(data, i)
        var marketId interface{} = this.SafeString(rawData, "symbol") // e.g., "BTCPFC"
        // BTSE uses different symbols in WebSocket (BTCPFC) vs REST API (BTC-PERP)
        // We need to map the WS symbol to the correct market
        var market interface{} = nil
        if ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(marketId, nil)) && ccxt.IsTrue(ccxt.EndsWith(marketId, "PFC"))) {
            // For perpetual futures, remove "PFC" suffix and add "-PERP"
            var baseSymbol interface{} = ccxt.Replace(marketId, "PFC", "")
            var perpId interface{} = ccxt.Add(baseSymbol, "-PERP")
            market = this.SafeMarket(perpId, nil, nil, "swap")
        } else if ccxt.IsTrue(!ccxt.IsEqual(marketId, nil)) {
            // For other symbols, try direct lookup
            market = this.SafeMarket(marketId, nil, nil, "swap")
        }
        var trade interface{} = this.ParseTrade(rawData, market)
        ccxt.AppendToArray(&tradesArray, trade)
        if ccxt.IsTrue(!ccxt.IsEqual(ccxt.GetValue(trade, "symbol"), nil)) {
            ccxt.AddElementToObject(symbolsByMarketId, marketId, ccxt.GetValue(trade, "symbol"))
        }
    }
    var first interface{} = this.SafeValue(tradesArray, 0, map[string]interface{} {})
    var symbol interface{} = this.SafeString(first, "symbol")
    if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
        return message
    }
    var stored interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        stored = ccxt.NewArrayCacheBySymbolById(limit)
        ccxt.AddElementToObject(this.Trades, symbol, stored)
    }
    // BTSE sends trades in descending order (newest first)
    // ccxt.Reverse to ascending order (oldest first) as expected by CCXT
    var reversedTrades interface{} = ccxt.Reverse(tradesArray)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(reversedTrades)); i++ {
        stored.(ccxt.Appender).Append(ccxt.GetValue(reversedTrades, i))
    }
    var messageHash interface{} = ccxt.Add("trades:", symbol)
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
    return message
}
/**
 * @method
 * @name btse#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *BtseCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes7288 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7288)
            var market interface{} = this.Market(symbol)
            var url interface{} = this.GetUrl(false, false, market)
            var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("ohlcv:", symbol), ":"), timeframe)
            var topic interface{} = ccxt.Add(ccxt.Add(ccxt.Add("kline:", ccxt.GetValue(market, "id")), "_"), timeframe)
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": []interface{}{topic},
            }
        
            ohlcv:= (<-this.Watch(url, messageHash, request, messageHash))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btse#watchOHLCVForSymbols
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
 * @param {string[][]} symbolsAndTimeframes array of arrays containing unified symbols and timeframes to fetch ccxt.OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *BtseCore) WatchOHLCVForSymbols(symbolsAndTimeframes interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes7568 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7568)
            var messageHashes interface{} = []interface{}{}
            var topics interface{} = []interface{}{}
            var firstMarket interface{} = nil
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbolsAndTimeframes)); i++ {
                var symbolAndTimeframe interface{} = ccxt.GetValue(symbolsAndTimeframes, i)
                var symbol interface{} = ccxt.GetValue(symbolAndTimeframe, 0)
                var timeframe interface{} = ccxt.GetValue(symbolAndTimeframe, 1)
                var market interface{} = this.Market(symbol)
                if ccxt.IsTrue(ccxt.IsEqual(i, 0)) {
                    firstMarket = market
                }
                var topic interface{} = ccxt.Add(ccxt.Add(ccxt.Add("kline:", ccxt.GetValue(market, "id")), "_"), timeframe)
                ccxt.AppendToArray(&topics, topic)
                ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(ccxt.Add("ohlcv:", symbol), ":"), timeframe))
            }
            var url interface{} = this.GetUrl(false, false, firstMarket)
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": topics,
            }
        
            ohlcv:= (<-this.WatchMultiple(url, messageHashes, request, messageHashes))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- ohlcv
                return nil
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btse#unWatchOHLCV
 * @description unwatch ccxt.OHLCV
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
 * @param {string} symbol unified symbol of the market to unwatch ccxt.OHLCV for
 * @param {string} timeframe the length of time each candle represents
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {any} status
 */
func  (this *BtseCore) UnWatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
                retRes79515 :=  (<-this.UnWatchOHLCVForSymbols([]interface{}{[]interface{}{symbol, timeframe}}, params))
                ccxt.PanicOnError(retRes79515)
                ch <- retRes79515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btse#unWatchOHLCVForSymbols
 * @description unwatch ccxt.OHLCV for symbols
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
 * @param {string[][]} symbolsAndTimeframes array of arrays containing unified symbols and timeframes
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {any} status
 */
func  (this *BtseCore) UnWatchOHLCVForSymbols(symbolsAndTimeframes interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes8088 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes8088)
            var topics interface{} = []interface{}{}
            var firstMarket interface{} = nil
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbolsAndTimeframes)); i++ {
                var symbolAndTimeframe interface{} = ccxt.GetValue(symbolsAndTimeframes, i)
                var symbol interface{} = ccxt.GetValue(symbolAndTimeframe, 0)
                var timeframe interface{} = ccxt.GetValue(symbolAndTimeframe, 1)
                var market interface{} = this.Market(symbol)
                if ccxt.IsTrue(ccxt.IsEqual(i, 0)) {
                    firstMarket = market
                }
                var topic interface{} = ccxt.Add(ccxt.Add(ccxt.Add("kline:", ccxt.GetValue(market, "id")), "_"), timeframe)
                ccxt.AppendToArray(&topics, topic)
            }
            var url interface{} = this.GetUrl(false, false, firstMarket)
            var request interface{} = map[string]interface{} {
                "op": "unsubscribe",
                "args": topics,
            }
        
                retRes82715 :=  (<-this.Watch(url, "unsubscribe:ohlcv", request, "unsubscribe:ohlcv"))
                ccxt.PanicOnError(retRes82715)
                ch <- retRes82715
                return nil
        
            }()
            return ch
        }
func  (this *BtseCore) HandleOHLCV(client interface{}, message interface{}) interface{}  {
    //
    // {
    //   "topic": "kline:BTC-PERP_1m",
    //   "data": {
    //     "symbol": "BTC-PERP",
    //     "interval": "1m",
    //     "openTime": 1680751500000,
    //     "closeTime": 1680751559999,
    //     "open": "28050.0",
    //     "high": "28070.0",
    //     "low": "28045.0",
    //     "close": "28065.0",
    //     "volume": "125.5",
    //     "timestamp": 1680751559999
    //   }
    // }
    //
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "symbol")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var interval interface{} = this.SafeString(data, "interval")
    var timeframe interface{} = this.FindTimeframe(interval)
    var parsed interface{} = []interface{}{this.SafeInteger(data, "timestamp"), this.SafeFloat(data, "open"), this.SafeFloat(data, "high"), this.SafeFloat(data, "low"), this.SafeFloat(data, "close"), this.SafeFloat(data, "volume")}
    var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("ohlcv:", symbol), ":"), timeframe)
    var stored interface{} = this.SafeValue(this.Ohlcvs, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        stored = map[string]interface{} {}
        ccxt.AddElementToObject(this.Ohlcvs, symbol, stored)
    }
    var storedArray interface{} = this.SafeValue(stored, timeframe)
    if ccxt.IsTrue(ccxt.IsEqual(storedArray, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
        storedArray = ccxt.NewArrayCacheByTimestamp(limit)
        ccxt.AddElementToObject(stored, timeframe, storedArray)
    }
    storedArray.(ccxt.Appender).Append(parsed)
    client.(ccxt.ClientInterface).Resolve(storedArray, messageHash)
    return message
}
/**
 * @method
 * @name btse#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
 * @param {string} [symbol] unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *BtseCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes8918 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes8918)
        
            retRes8928 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes8928)
            var url interface{} = this.GetUrl(true)
            var messageHash interface{} = "orders"
            var topic interface{} = "orders"
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": []interface{}{topic},
            }
        
            orders:= (<-this.Watch(url, messageHash, request, messageHash))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btse#unWatchOrders
 * @description unwatch orders
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
 * @param {string} [symbol] unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {any} status
 */
func  (this *BtseCore) UnWatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes9178 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes9178)
            var url interface{} = this.GetUrl(true)
            var topic interface{} = "orders"
            var request interface{} = map[string]interface{} {
                "op": "unsubscribe",
                "args": []interface{}{topic},
            }
        
                retRes92415 :=  (<-this.Watch(url, "unsubscribe:orders", request, "unsubscribe:orders"))
                ccxt.PanicOnError(retRes92415)
                ch <- retRes92415
                return nil
        
            }()
            return ch
        }
func  (this *BtseCore) HandleOrders(client interface{}, message interface{}) interface{}  {
    //
    // {
    //   "topic": "orders",
    //   "data": [{
    //     "orderId": "order123",
    //     "clientOrderId": "client456",
    //     "symbol": "BTC-PERP",
    //     "orderType": "LIMIT",
    //     "side": "BUY",
    //     "price": "28000.0",
    //     "size": "1.0",
    //     "filledSize": "0.5",
    //     "avgFillPrice": "28000.0",
    //     "status": "PARTIAL_FILLED",
    //     "triggerPrice": null,
    //     "timestamp": 1680751558529
    //   }]
    // }
    //
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    var ordersArray interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var order interface{} = this.ParseOrder(ccxt.GetValue(data, i))
        ccxt.AppendToArray(&ordersArray, order)
    }
    var stored interface{} = this.Orders
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        stored = ccxt.NewArrayCacheBySymbolById(limit)
        this.Orders = stored
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(ordersArray)); i++ {
        stored.(ccxt.Appender).Append(ccxt.GetValue(ordersArray, i))
    }
    var messageHash interface{} = "orders"
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
    return message
}
/**
 * @method
 * @name btse#watchMyTrades
 * @description watches information on multiple trades made by the user
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
 * @param {string} [symbol] unified market symbol of the market trades were made in
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *BtseCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes9798 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes9798)
        
            retRes9808 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes9808)
            var url interface{} = this.GetUrl(true)
            var messageHash interface{} = "myTrades"
            var topic interface{} = "fills"
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": []interface{}{topic},
            }
        
            trades:= (<-this.Watch(url, messageHash, request, messageHash))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(trades, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btse#unWatchMyTrades
 * @description unwatch my trades
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
 * @param {string} [symbol] unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {any} status
 */
func  (this *BtseCore) UnWatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes10058 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes10058)
            var url interface{} = this.GetUrl(true)
            var topic interface{} = "fills"
            var request interface{} = map[string]interface{} {
                "op": "unsubscribe",
                "args": []interface{}{topic},
            }
        
                retRes101215 :=  (<-this.Watch(url, "unsubscribe:myTrades", request, "unsubscribe:myTrades"))
                ccxt.PanicOnError(retRes101215)
                ch <- retRes101215
                return nil
        
            }()
            return ch
        }
func  (this *BtseCore) HandleMyTrades(client interface{}, message interface{}) interface{}  {
    //
    // {
    //   "topic": "fills",
    //   "data": [{
    //     "orderId": "order123",
    //     "tradeId": "trade789",
    //     "symbol": "BTC-PERP",
    //     "side": "BUY",
    //     "price": "28000.0",
    //     "size": "0.5",
    //     "fee": "0.00005",
    //     "feeCurrency": "BTC",
    //     "feeRate": "0.0001",
    //     "maker": false,
    //     "timestamp": 1680751558529
    //   }]
    // }
    //
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    var tradesArray interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var trade interface{} = this.ParseOrder(ccxt.GetValue(data, i))
        ccxt.AppendToArray(&tradesArray, trade)
    }
    var stored interface{} = this.MyTrades
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        stored = ccxt.NewArrayCacheBySymbolById(limit)
        this.MyTrades = stored
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(tradesArray)); i++ {
        stored.(ccxt.Appender).Append(ccxt.GetValue(tradesArray, i))
    }
    var messageHash interface{} = "myTrades"
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
    return message
}
/**
 * @method
 * @name btse#watchPositions
 * @description watch all open positions
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {int} [since] the earliest time in ms to fetch positions for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *BtseCore) WatchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes10658 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes10658)
        
            retRes10668 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes10668)
            symbols = this.MarketSymbols(symbols, nil, false)
            var url interface{} = this.GetUrl(true)
            var messageHash interface{} = "positionsV3"
            var topic interface{} = "positionsV3"
            var options interface{} = this.SafeValue(this.Options, "watchPositions", map[string]interface{} {})
            var fetchPositionsSnapshot interface{} = this.SafeBool(options, "fetchPositionsSnapshot", true)
            var awaitPositionsSnapshot interface{} = this.SafeBool(options, "awaitPositionsSnapshot", true)
            if ccxt.IsTrue(ccxt.IsTrue(fetchPositionsSnapshot) && ccxt.IsTrue(awaitPositionsSnapshot)) {
        
                snapshot:= (<-this.FetchPositions(symbols))
                ccxt.PanicOnError(snapshot)
                if ccxt.IsTrue(ccxt.IsEqual(this.Positions, nil)) {
                    this.Positions = ccxt.NewArrayCacheBySymbolById()
                }
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(snapshot)); i++ {
                    this.Positions.(ccxt.Appender).Append(ccxt.GetValue(snapshot, i))
                }
            }
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": []interface{}{topic},
            }
        
            positions:= (<-this.Watch(url, messageHash, request, messageHash))
            ccxt.PanicOnError(positions)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- positions
                return nil
            }
        
            ch <- this.FilterBySymbolsSinceLimit(positions, symbols, since, nil, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btse#unWatchPositions
 * @description unwatch positions
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
 * @param {string[]} [symbols] list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {any} status
 */
func  (this *BtseCore) UnWatchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes11048 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes11048)
            var url interface{} = this.GetUrl(true)
            var topic interface{} = "positionsV3"
            var request interface{} = map[string]interface{} {
                "op": "unsubscribe",
                "args": []interface{}{topic},
            }
        
                retRes111115 :=  (<-this.Watch(url, "unsubscribe:positionsV3", request, "unsubscribe:positionsV3"))
                ccxt.PanicOnError(retRes111115)
                ch <- retRes111115
                return nil
        
            }()
            return ch
        }
func  (this *BtseCore) HandlePositions(client interface{}, message interface{}) interface{}  {
    //
    // {
    //   "topic": "positionsV3",
    //   "data": [{
    //     "marketName": "QA-PERP-USDT",
    //     "entryPrice": 1500,
    //     "markedPrice": 1500,
    //     "liquidationPrice": 0,
    //     "unrealizedProfitLoss": 0,
    //     "totalContracts": 666,
    //     "marginTypeName": "FUTURES_MARGIN_CROSS",
    //     "currentLeverage": 0.0999085912,
    //     "positionId": "QA-PERP-USDT",
    //     "positionMode": "ONE_WAY",
    //     "positionDirection": "LONG",
    //     "contractSize": 0.01,
    //     "totalValue": 9990
    //   }]
    // }
    //
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    var positionsArray interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var position interface{} = this.ParsePosition(ccxt.GetValue(data, i))
        ccxt.AppendToArray(&positionsArray, position)
    }
    if ccxt.IsTrue(ccxt.IsEqual(this.Positions, nil)) {
        this.Positions = ccxt.NewArrayCacheBySymbolById()
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(positionsArray)); i++ {
        this.Positions.(ccxt.Appender).Append(ccxt.GetValue(positionsArray, i))
    }
    var messageHash interface{} = "positionsV3"
    client.(ccxt.ClientInterface).Resolve(this.Positions, messageHash)
    return message
}
/**
 * @method
 * @name btse#watchBalance
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *BtseCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes11618 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes11618)
        
            retRes11628 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes11628)
            var url interface{} = this.GetUrl(true)
            var messageHash interface{} = "balance"
            var topic interface{} = "wallet"
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": []interface{}{topic},
            }
        
                retRes117015 :=  (<-this.Watch(url, messageHash, request, messageHash))
                ccxt.PanicOnError(retRes117015)
                ch <- retRes117015
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btse#unWatchBalance
 * @description unwatch balance
 * @see https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {any} status
 */
func  (this *BtseCore) UnWatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes11828 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes11828)
            var url interface{} = this.GetUrl(true)
            var topic interface{} = "wallet"
            var request interface{} = map[string]interface{} {
                "op": "unsubscribe",
                "args": []interface{}{topic},
            }
        
                retRes118915 :=  (<-this.Watch(url, "unsubscribe:balance", request, "unsubscribe:balance"))
                ccxt.PanicOnError(retRes118915)
                ch <- retRes118915
                return nil
        
            }()
            return ch
        }
func  (this *BtseCore) HandleBalance(client interface{}, message interface{}) interface{}  {
    //
    // {
    //   "topic": "wallet",
    //   "data": [{
    //     "currency": "USDT",
    //     "total": "10000.0",
    //     "available": "8500.0",
    //     "reserved": "1500.0",
    //     "timestamp": 1680751558529
    //   }, {
    //     "currency": "BTC",
    //     "total": "0.5",
    //     "available": "0.3",
    //     "reserved": "0.2",
    //     "timestamp": 1680751558529
    //   }]
    // }
    //
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    ccxt.AddElementToObject(this.Balance, "info", message)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var balance interface{} = ccxt.GetValue(data, i)
        var currencyId interface{} = this.SafeString(balance, "currency")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        ccxt.AddElementToObject(account, "free", this.SafeString(balance, "available"))
        ccxt.AddElementToObject(account, "used", this.SafeString(balance, "reserved"))
        ccxt.AddElementToObject(account, "total", this.SafeString(balance, "total"))
        ccxt.AddElementToObject(this.Balance, code, account)
    }
    this.Balance = this.SafeBalance(this.Balance)
    var messageHash interface{} = "balance"
    client.(ccxt.ClientInterface).Resolve(this.Balance, messageHash)
    return message
}


func (this *BtseCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}

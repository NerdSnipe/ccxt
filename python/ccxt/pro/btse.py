# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

import ccxt.async_support
from ccxt.async_support.base.ws.cache import ArrayCacheBySymbolById, ArrayCacheByTimestamp
import hashlib
from ccxt.base.types import Any, Balances, Int, Order, OrderBook, Position, Str, Strings, Ticker, Tickers, Trade
from ccxt.async_support.base.ws.client import Client
from typing import List
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import BadSymbol
from ccxt.base.errors import RateLimitExceeded


class btse(ccxt.async_support.btse):

    def describe(self) -> Any:
        return self.deep_extend(super(btse, self).describe(), {
            'has': {
                'ws': True,
                # BTSE does NOT support WebSocket order placement/modification
                # Orders must be placed via REST API only
                'createOrderWs': False,
                'editOrderWs': False,
                'cancelOrderWs': False,
                'cancelAllOrdersWs': False,
                'watchBalance': True,
                'watchMyTrades': True,
                'watchOHLCV': True,
                'watchOHLCVForSymbols': True,
                'watchOrderBook': True,
                'watchOrderBookForSymbols': True,
                'watchOrders': True,
                'watchTicker': True,
                'watchTickers': True,
                'watchTrades': True,
                'watchTradesForSymbols': True,
                'watchPositions': True,
                'unWatchTicker': True,
                'unWatchTickers': True,
                'unWatchOHLCV': True,
                'unWatchOHLCVForSymbols': True,
                'unWatchOrderBook': True,
                'unWatchOrderBookForSymbols': True,
                'unWatchTrades': True,
                'unWatchTradesForSymbols': True,
                'unWatchMyTrades': True,
                'unWatchOrders': True,
                'unWatchPositions': True,
                'unWatchBalance': True,
            },
            'urls': {
                'api': {
                    'ws': {
                        'public': 'wss://ws.btse.com/ws/futures',
                        'orderbook': 'wss://ws.btse.com/ws/oss/futures',
                        'private': 'wss://ws.btse.com/ws/futures',
                        'publicSpot': 'wss://ws.btse.com/ws/spot',
                        'orderbookSpot': 'wss://ws.btse.com/ws/oss/spot',
                        'privateSpot': 'wss://ws.btse.com/ws/spot',
                    },
                },
                'test': {
                    'ws': {
                        'public': 'wss://testws.btse.io/ws/futures',
                        'orderbook': 'wss://testws.btse.io/ws/oss/futures',
                        'private': 'wss://testws.btse.io/ws/futures',
                        'publicSpot': 'wss://testws.btse.io/ws/spot',
                        'orderbookSpot': 'wss://testws.btse.io/ws/oss/spot',
                        'privateSpot': 'wss://testws.btse.io/ws/spot',
                    },
                },
            },
            'options': {
                'watchOrderBook': {
                    'grouping': '0',  # default grouping level(0, 1, 2, 3)
                    'type': 'snapshotL2',  # 'snapshotL1' or 'snapshotL2'
                },
                'watchPositions': {
                    'fetchPositionsSnapshot': True,  # fetch initial snapshot via REST
                    'awaitPositionsSnapshot': True,  # wait for snapshot before providing updates
                },
                'requestId': 0,  # for generating unique request IDs
            },
            'streaming': {
                # BTSE does not respond to pings, so disable ping/pong keepalive
            },
        })

    def request_id(self):
        requestId = self.sum(self.safe_integer(self.options, 'requestId', 0), 1)
        self.options['requestId'] = requestId
        return requestId

    def get_url(self, isPrivate=False, isOrderbook=False, market=None):
        urls = self.safe_value(self.urls, self.options['defaultType'], self.urls['api'])
        ws = self.safe_value(urls, 'ws', {})
        # Determine if self is a SPOT market
        isSpot = (market is not None) and self.safe_value(market, 'spot', False)
        # Select appropriate endpoint based on market type
        if isOrderbook:
            return self.safe_string(ws, 'orderbookSpot' if isSpot else 'orderbook')
        elif isPrivate:
            return self.safe_string(ws, 'privateSpot' if isSpot else 'private')
        else:
            return self.safe_string(ws, 'publicSpot' if isSpot else 'public')

    async def authenticate(self, params={}):
        url = self.get_url(True)
        client = self.client(url)
        messageHash = 'authenticated'
        future = self.safe_value(client.subscriptions, messageHash)
        if future is None:
            self.check_required_credentials()
            nonce = self.nonce()
            path = '/ws/futures'
            auth = path + str(nonce)
            signature = self.hmac(self.encode(auth), self.encode(self.secret), hashlib.sha384, 'hex')
            request: dict = {
                'op': 'authKeyExpires',
                'args': [
                    self.apiKey,
                    nonce,
                    signature,
                ],
            }
            future = await self.watch(url, messageHash, request, messageHash)
        return future

    def ping(self, client: Client):
        return {
            'op': 'ping',
        }

    def handle_pong(self, client: Client, message: Any) -> Any:
        # Message = self.milliseconds()
        pass

    def handle_message(self, client: Client, message: Any):
        topic = self.safe_string(message, 'topic')
        op = self.safe_string(message, 'op')
        # Handle operational messages
        if op == 'pong':
            self.handle_pong(client, message)
        elif op == 'subscribe' or op == 'unsubscribe':
            self.handle_subscription_status(client, message)
        elif op == 'authKeyExpires':
            self.handle_authentication_message(client, message)
        # Handle data messages by topic
        if topic is not None:
            if topic.find('ticker:') == 0:
                self.handle_ticker(client, message)
            elif topic.find('snapshotL1:') == 0 or topic.find('snapshotL2:') == 0:
                self.handle_order_book(client, message)
            elif topic == 'trades' or topic.find('trades:') == 0 or topic.find('tradeHistoryApi') == 0:
                # BTSE FUTURES uses "tradeHistoryApiV3:BTC-PERP"
                # BTSE SPOT uses "tradeHistoryApi:BTC-USD"
                self.handle_trades(client, message)
            elif topic.find('kline:') == 0:
                self.handle_ohlcv(client, message)
            elif topic == 'orders':
                self.handle_orders(client, message)
            elif topic == 'fills':
                self.handle_my_trades(client, message)
            elif topic == 'positionsV3':
                self.handle_positions(client, message)
            elif topic == 'wallet':
                self.handle_balance(client, message)
            elif topic == 'error':
                self.handle_error(client, message)

    def handle_subscription_status(self, client: Client, message: Any) -> Any:
        # Handle subscription/unsubscription confirmation
        return message

    def handle_authentication_message(self, client: Client, message: Any) -> Any:
        messageHash = 'authenticated'
        future = self.safe_value(client.subscriptions, messageHash)
        if future is not None:
            future.resolve(True)
        return message

    def handle_error(self, client: Client, message: Any) -> bool:
        # Error format:
        # {
        #   "topic": "error",
        #   "code": 4001,
        #   "message": "Invalid symbol"
        # }
        code = self.safe_integer(message, 'code')
        errorMessage = self.safe_string(message, 'message')
        if code is not None:
            if code == 4001:
                raise BadSymbol(errorMessage)
            elif code == 4003:
                raise AuthenticationError(errorMessage)
            elif code == 4004:
                raise ExchangeError(errorMessage)  # RateLimitExceeded
            raise ExchangeError(errorMessage)
        return False

    async def watch_ticker(self, symbol: str, params={}) -> Ticker:
        """
        watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market

        https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams

        :param str symbol: unified symbol of the market to fetch the ticker for
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a `ticker structure <https://docs.ccxt.com/#/?id=ticker-structure>`
        """
        await self.load_markets()
        market = self.market(symbol)
        url = self.get_url(False, False, market)
        messageHash = 'ticker:' + symbol
        topic = 'ticker:' + market['id']
        request: dict = {
            'op': 'subscribe',
            'args': [topic],
        }
        return await self.watch(url, messageHash, request, messageHash)

    async def watch_tickers(self, symbols: Strings = None, params={}) -> Tickers:
        """
        watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list

        https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams

        :param str[] symbols: unified symbol of the market to fetch the ticker for
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a `ticker structure <https://docs.ccxt.com/#/?id=ticker-structure>`
        """
        await self.load_markets()
        symbols = self.market_symbols(symbols, None, False)
        messageHashes = []
        topics = []
        firstMarket = None
        for i in range(0, len(symbols)):
            symbol = symbols[i]
            market = self.market(symbol)
            if i == 0:
                firstMarket = market
            topic = 'ticker:' + market['id']
            topics.append(topic)
            messageHashes.append('ticker:' + symbol)
        url = self.get_url(False, False, firstMarket)
        request: dict = {
            'op': 'subscribe',
            'args': topics,
        }
        ticker = await self.watch_multiple(url, messageHashes, request, messageHashes)
        if self.newUpdates:
            result: dict = {}
            result[ticker['symbol']] = ticker
            return result
        return self.filter_by_array(self.tickers, 'symbol', symbols)

    async def un_watch_ticker(self, symbol: str, params={}) -> Any:
        """
        unwatch a price ticker

        https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams

        :param str symbol: unified symbol of the market to unwatch the ticker for
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns any: status
        """
        return await self.un_watch_tickers([symbol], params)

    async def un_watch_tickers(self, symbols: Strings = None, params={}) -> Any:
        """
        unwatch price tickers

        https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams

        :param str[] symbols: unified symbols of the markets to unwatch the tickers for
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns any: status
        """
        await self.load_markets()
        symbols = self.market_symbols(symbols, None, False)
        topics = []
        firstMarket = None
        for i in range(0, len(symbols)):
            symbol = symbols[i]
            market = self.market(symbol)
            if i == 0:
                firstMarket = market
            topic = 'ticker:' + market['id']
            topics.append(topic)
        url = self.get_url(False, False, firstMarket)
        request: dict = {
            'op': 'unsubscribe',
            'args': topics,
        }
        return await self.watch(url, 'unsubscribe:ticker', request, 'unsubscribe:ticker')

    def handle_ticker(self, client: Client, message: Any) -> Any:
        #
        # {
        #   "topic": "ticker:BTC-PERP",
        #   "data": {
        #     "symbol": "BTC-PERP",
        #     "last": "28065.0",
        #     "lowestAsk": "28065.0",
        #     "highestBid": "28064.5",
        #     "volume24h": "123456.78",
        #     "high24h": "28500.0",
        #     "low24h": "27500.0",
        #     "timestamp": 1680751558529
        #   }
        # }
        #
        data = self.safe_dict(message, 'data', {})
        ticker = self.parse_ticker(data)
        symbol = ticker['symbol']
        self.tickers[symbol] = ticker
        messageHash = 'ticker:' + symbol
        client.resolve(ticker, messageHash)
        return message

    async def watch_order_book(self, symbol: str, limit: Int = None, params={}) -> OrderBook:
        """
        watches information on open orders with bid(buy) and ask(sell) prices, volumes and other data

        https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams

        :param str symbol: unified symbol of the market to fetch the order book for
        :param int [limit]: the maximum amount of order book entries to return
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.grouping]: orderbook grouping level, '0', '1', '2', '3'(default '0')
        :returns dict: A dictionary of `order book structures <https://docs.ccxt.com/#/?id=order-book-structure>` indexed by market symbols
        """
        await self.load_markets()
        market = self.market(symbol)
        url = self.get_url(False, True, market)  # Use orderbook URL
        options = self.safe_value(self.options, 'watchOrderBook', {})
        grouping = self.safe_string_2(params, 'grouping', 'group', self.safe_string(options, 'grouping', '0'))
        type = self.safe_string(options, 'type', 'snapshotL2')
        messageHash = 'orderbook:' + symbol
        topic = type + ':' + market['id'] + '_' + grouping
        request: dict = {
            'op': 'subscribe',
            'args': [topic],
        }
        orderbook = await self.watch(url, messageHash, request, messageHash)
        return orderbook.limit()

    async def watch_order_book_for_symbols(self, symbols: List[str], limit: Int = None, params={}) -> OrderBook:
        """
        watches information on open orders with bid(buy) and ask(sell) prices, volumes and other data

        https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams

        :param str[] symbols: unified array of symbols
        :param int [limit]: the maximum amount of order book entries to return
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.grouping]: orderbook grouping level, '0', '1', '2', '3'(default '0')
        :returns dict: A dictionary of `order book structures <https://docs.ccxt.com/#/?id=order-book-structure>` indexed by market symbols
        """
        await self.load_markets()
        firstMarket = self.market(symbols[0])
        url = self.get_url(False, True, firstMarket)
        options = self.safe_value(self.options, 'watchOrderBook', {})
        grouping = self.safe_string_2(params, 'grouping', 'group', self.safe_string(options, 'grouping', '0'))
        type = self.safe_string(options, 'type', 'snapshotL2')
        messageHashes = []
        topics = []
        for i in range(0, len(symbols)):
            symbol = symbols[i]
            market = self.market(symbol)
            topic = type + ':' + market['id'] + '_' + grouping
            topics.append(topic)
            messageHashes.append('orderbook:' + symbol)
        request: dict = {
            'op': 'subscribe',
            'args': topics,
        }
        orderbook = await self.watch_multiple(url, messageHashes, request, messageHashes)
        return orderbook.limit()

    async def un_watch_order_book(self, symbol: str, params={}) -> Any:
        """
        unwatch orderbook

        https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams

        :param str symbol: unified symbol of the market to unwatch the orderbook for
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns any: status
        """
        return await self.un_watch_order_book_for_symbols([symbol], params)

    async def un_watch_order_book_for_symbols(self, symbols: List[str], params={}) -> Any:
        """
        unwatch orderbook for symbols

        https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams

        :param str[] symbols: unified symbols of the markets to unwatch the orderbooks for
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns any: status
        """
        await self.load_markets()
        options = self.safe_value(self.options, 'watchOrderBook', {})
        grouping = self.safe_string_2(params, 'grouping', 'group', self.safe_string(options, 'grouping', '0'))
        type = self.safe_string(options, 'type', 'snapshotL2')
        topics = []
        firstMarket = None
        for i in range(0, len(symbols)):
            symbol = symbols[i]
            market = self.market(symbol)
            if i == 0:
                firstMarket = market
            topic = type + ':' + market['id'] + '_' + grouping
            topics.append(topic)
        url = self.get_url(False, True, firstMarket)
        request: dict = {
            'op': 'unsubscribe',
            'args': topics,
        }
        return await self.watch(url, 'unsubscribe:orderbook', request, 'unsubscribe:orderbook')

    def handle_order_book(self, client: Client, message: Any) -> Any:
        #
        # Snapshot:
        # {
        #   "topic": "snapshotL2:BTC-PERP_0",
        #   "data": {
        #     "bids": [["28064.5", "1250"], ["28064.0", "850"]],
        #     "asks": [["28065.0", "1015"], ["28065.5", "720"]],
        #     "type": "snapshot",
        #     "symbol": "BTC-PERP",
        #     "timestamp": 1680751558529,
        #     "prevSeqNum": 0,
        #     "seqNum": 12345
        #   }
        # }
        #
        # Delta:
        # {
        #   "topic": "snapshotL2:BTC-PERP_0",
        #   "data": {
        #     "bids": [["28064.5", "1300"]],
        #     "asks": [],
        #     "type": "delta",
        #     "symbol": "BTC-PERP",
        #     "timestamp": 1680751559000,
        #     "prevSeqNum": 12345,
        #     "seqNum": 12346
        #   }
        # }
        #
        data = self.safe_dict(message, 'data', {})
        marketId = self.safe_string(data, 'symbol')
        market = self.safe_market(marketId)
        symbol = market['symbol']
        type = self.safe_string(data, 'type')
        timestamp = self.safe_integer(data, 'timestamp')
        seqNum = self.safe_integer(data, 'seqNum')
        if type == 'snapshot':
            snapshot = self.parse_order_book(data, symbol, timestamp)
            snapshot['nonce'] = seqNum
            orderbook = self.safe_value(self.orderbooks, symbol)
            if orderbook is None:
                orderbook = self.order_book(snapshot)
            else:
                orderbook.reset(snapshot)
            self.orderbooks[symbol] = orderbook
        elif type == 'delta':
            orderbook = self.safe_value(self.orderbooks, symbol)
            if orderbook is None:
                # Wait for snapshot
                return message
            bids = self.safe_list(data, 'bids', [])
            asks = self.safe_list(data, 'asks', [])
            self.handle_deltas(orderbook['bids'], bids)
            self.handle_deltas(orderbook['asks'], asks)
            orderbook['nonce'] = seqNum
            orderbook['timestamp'] = timestamp
            orderbook['datetime'] = self.iso8601(timestamp)
            self.orderbooks[symbol] = orderbook
        messageHash = 'orderbook:' + symbol
        client.resolve(self.orderbooks[symbol], messageHash)
        return message

    def handle_deltas(self, bookSide, deltas):
        for i in range(0, len(deltas)):
            delta = deltas[i]
            price = self.safe_float(delta, 0)
            amount = self.safe_float(delta, 1)
            bookSide.store(price, amount)

    async def watch_trades(self, symbol: str, since: Int = None, limit: Int = None, params={}) -> List[Trade]:
        """
        get the list of most recent trades for a particular symbol

        https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams

        :param str symbol: unified symbol of the market to fetch trades for
        :param int [since]: timestamp in ms of the earliest trade to fetch
        :param int [limit]: the maximum amount of trades to fetch
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict[]: a list of `trade structures <https://docs.ccxt.com/#/?id=public-trades>`
        """
        await self.load_markets()
        market = self.market(symbol)
        url = self.get_url(False, False, market)
        messageHash = 'trades:' + symbol
        # SPOT uses 'tradeHistoryApi:', FUTURES uses 'tradeHistoryApiV3:'
        topicPrefix = market['spot'] ? 'tradeHistoryApi:' : 'tradeHistoryApiV3:'
        topic = topicPrefix + market['id']
        request: dict = {
            'op': 'subscribe',
            'args': [topic],
        }
        trades = await self.watch(url, messageHash, request, messageHash)
        if self.newUpdates:
            limit = trades.getLimit(symbol, limit)
        return self.filter_by_since_limit(trades, since, limit, 'timestamp', True)

    async def watch_trades_for_symbols(self, symbols: List[str], since: Int = None, limit: Int = None, params={}) -> List[Trade]:
        """
        get the list of most recent trades for a particular symbol

        https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams

        :param str[] symbols: unified symbols of the markets to fetch trades for
        :param int [since]: timestamp in ms of the earliest trade to fetch
        :param int [limit]: the maximum amount of trades to fetch
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict[]: a list of `trade structures <https://docs.ccxt.com/#/?id=public-trades>`
        """
        await self.load_markets()
        messageHashes = []
        topics = []
        firstMarket = None
        for i in range(0, len(symbols)):
            symbol = symbols[i]
            market = self.market(symbol)
            if i == 0:
                firstMarket = market
            # SPOT uses 'tradeHistoryApi:', FUTURES uses 'tradeHistoryApiV3:'
            topicPrefix = market['spot'] ? 'tradeHistoryApi:' : 'tradeHistoryApiV3:'
            topic = topicPrefix + market['id']
            topics.append(topic)
            messageHashes.append('trades:' + symbol)
        url = self.get_url(False, False, firstMarket)
        request: dict = {
            'op': 'subscribe',
            'args': topics,
        }
        trades = await self.watch_multiple(url, messageHashes, request, messageHashes)
        if self.newUpdates:
            if trades is not None:
                first = self.safe_value(trades, 0)
                symbol = self.safe_string(first, 'symbol')
                limit = trades.getLimit(symbol, limit)
        if trades is None:
            return []
        return self.filter_by_since_limit(trades, since, limit, 'timestamp', True)

    async def un_watch_trades(self, symbol: str, params={}) -> Any:
        """
        unwatch trades

        https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams

        :param str symbol: unified symbol of the market to unwatch trades for
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns any: status
        """
        return await self.un_watch_trades_for_symbols([symbol], params)

    async def un_watch_trades_for_symbols(self, symbols: List[str], params={}) -> Any:
        """
        unwatch trades for symbols

        https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams

        :param str[] symbols: unified symbols of the markets to unwatch trades for
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns any: status
        """
        await self.load_markets()
        topics = []
        firstMarket = None
        for i in range(0, len(symbols)):
            symbol = symbols[i]
            market = self.market(symbol)
            if i == 0:
                firstMarket = market
            # SPOT uses 'tradeHistoryApi:', FUTURES uses 'tradeHistoryApiV3:'
            topicPrefix = market['spot'] ? 'tradeHistoryApi:' : 'tradeHistoryApiV3:'
            topic = topicPrefix + market['id']
            topics.append(topic)
        url = self.get_url(False, False, firstMarket)
        request: dict = {
            'op': 'unsubscribe',
            'args': topics,
        }
        return await self.watch(url, 'unsubscribe:trades', request, 'unsubscribe:trades')

    def handle_trades(self, client: Client, message: Any) -> Any:
        #
        # {
        #   "topic": "trades",
        #   "data": [{
        #     "symbol": "BTCPFC",  # Note: BTSE uses different symbols in WS vs REST
        #     "side": "BUY",
        #     "size": "0.5",
        #     "price": "28065.0",
        #     "tradeId": "abc123def",
        #     "timestamp": 1680751558529
        #   }]
        # }
        #
        data = self.safe_list(message, 'data', [])
        # BTSE sends "BTCPFC" for BTC-PERP in WebSocket messages
        # We need to find the correct market by looking at what we have in our markets
        tradesArray = []
        symbolsByMarketId = {}
        for i in range(0, len(data)):
            rawData = data[i]
            marketId = self.safe_string(rawData, 'symbol')  # e.g., "BTCPFC"
            # BTSE uses different symbols in WebSocket(BTCPFC) vs REST API(BTC-PERP)
            # We need to map the WS symbol to the correct market
            market = None
            if marketId is not None and marketId.endswith('PFC'):
                # For perpetual futures, remove "PFC" suffix and add "-PERP"
                baseSymbol = marketId.replace('PFC', '')
                perpId = baseSymbol + '-PERP'
                market = self.safe_market(perpId, None, None, 'swap')
            elif marketId is not None:
                # For other symbols, try direct lookup
                market = self.safe_market(marketId, None, None, 'swap')
            trade = self.parse_trade(rawData, market)
            tradesArray.append(trade)
            if trade['symbol'] is not None:
                symbolsByMarketId[marketId] = trade['symbol']
        first = self.safe_value(tradesArray, 0, {})
        symbol = self.safe_string(first, 'symbol')
        if symbol is None:
            return message
        stored = self.safe_value(self.trades, symbol)
        if stored is None:
            limit = self.safe_integer(self.options, 'tradesLimit', 1000)
            stored = ArrayCacheBySymbolById(limit)
            self.trades[symbol] = stored
        # BTSE sends trades in descending order(newest first)
        # Reverse to ascending order(oldest first) by CCXT
        tradesArray.reverse()
        for i in range(0, len(tradesArray)):
            stored.append(tradesArray[i])
        messageHash = 'trades:' + symbol
        client.resolve(stored, messageHash)
        return message

    async def watch_ohlcv(self, symbol: str, timeframe='1m', since: Int = None, limit: Int = None, params={}) -> List[list]:
        """
        watches historical candlestick data containing the open, high, low, and close price, and the volume of a market

        https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams

        :param str symbol: unified symbol of the market to fetch OHLCV data for
        :param str timeframe: the length of time each candle represents
        :param int [since]: timestamp in ms of the earliest candle to fetch
        :param int [limit]: the maximum amount of candles to fetch
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns int[][]: A list of candles ordered, open, high, low, close, volume
        """
        await self.load_markets()
        market = self.market(symbol)
        url = self.get_url(False, False, market)
        messageHash = 'ohlcv:' + symbol + ':' + timeframe
        topic = 'kline:' + market['id'] + '_' + timeframe
        request: dict = {
            'op': 'subscribe',
            'args': [topic],
        }
        ohlcv = await self.watch(url, messageHash, request, messageHash)
        if self.newUpdates:
            limit = ohlcv.getLimit(symbol, limit)
        return self.filter_by_since_limit(ohlcv, since, limit, 0, True)

    async def watch_ohlcv_for_symbols(self, symbolsAndTimeframes: List[List[str]], since: Int = None, limit: Int = None, params={}) -> Promise<Dictionary<Dictionary<OHLCV[]>>>:
        """
        watches historical candlestick data containing the open, high, low, and close price, and the volume of a market

        https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams

        :param str[][] symbolsAndTimeframes: array of arrays containing unified symbols and timeframes to fetch OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
        :param int [since]: timestamp in ms of the earliest candle to fetch
        :param int [limit]: the maximum amount of candles to fetch
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns int[][]: A list of candles ordered, open, high, low, close, volume
        """
        await self.load_markets()
        messageHashes = []
        topics = []
        firstMarket = None
        for i in range(0, len(symbolsAndTimeframes)):
            symbolAndTimeframe = symbolsAndTimeframes[i]
            symbol = symbolAndTimeframe[0]
            timeframe = symbolAndTimeframe[1]
            market = self.market(symbol)
            if i == 0:
                firstMarket = market
            topic = 'kline:' + market['id'] + '_' + timeframe
            topics.append(topic)
            messageHashes.append('ohlcv:' + symbol + ':' + timeframe)
        url = self.get_url(False, False, firstMarket)
        request: dict = {
            'op': 'subscribe',
            'args': topics,
        }
        ohlcv = await self.watch_multiple(url, messageHashes, request, messageHashes)
        if self.newUpdates:
            return ohlcv
        return self.filter_by_since_limit(ohlcv, since, limit, 0, True)

    async def un_watch_ohlcv(self, symbol: str, timeframe='1m', params={}) -> Any:
        """
        unwatch OHLCV

        https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams

        :param str symbol: unified symbol of the market to unwatch OHLCV for
        :param str timeframe: the length of time each candle represents
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns any: status
        """
        return await self.un_watch_ohlcv_for_symbols([[symbol, timeframe]], params)

    async def un_watch_ohlcv_for_symbols(self, symbolsAndTimeframes: List[List[str]], params={}) -> Any:
        """
        unwatch OHLCV for symbols

        https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams

        :param str[][] symbolsAndTimeframes: array of arrays containing unified symbols and timeframes
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns any: status
        """
        await self.load_markets()
        topics = []
        firstMarket = None
        for i in range(0, len(symbolsAndTimeframes)):
            symbolAndTimeframe = symbolsAndTimeframes[i]
            symbol = symbolAndTimeframe[0]
            timeframe = symbolAndTimeframe[1]
            market = self.market(symbol)
            if i == 0:
                firstMarket = market
            topic = 'kline:' + market['id'] + '_' + timeframe
            topics.append(topic)
        url = self.get_url(False, False, firstMarket)
        request: dict = {
            'op': 'unsubscribe',
            'args': topics,
        }
        return await self.watch(url, 'unsubscribe:ohlcv', request, 'unsubscribe:ohlcv')

    def handle_ohlcv(self, client: Client, message: Any) -> Any:
        #
        # {
        #   "topic": "kline:BTC-PERP_1m",
        #   "data": {
        #     "symbol": "BTC-PERP",
        #     "interval": "1m",
        #     "openTime": 1680751500000,
        #     "closeTime": 1680751559999,
        #     "open": "28050.0",
        #     "high": "28070.0",
        #     "low": "28045.0",
        #     "close": "28065.0",
        #     "volume": "125.5",
        #     "timestamp": 1680751559999
        #   }
        # }
        #
        data = self.safe_dict(message, 'data', {})
        marketId = self.safe_string(data, 'symbol')
        market = self.safe_market(marketId)
        symbol = market['symbol']
        interval = self.safe_string(data, 'interval')
        timeframe = self.find_timeframe(interval)
        parsed = [
            self.safe_integer(data, 'timestamp'),
            self.safe_float(data, 'open'),
            self.safe_float(data, 'high'),
            self.safe_float(data, 'low'),
            self.safe_float(data, 'close'),
            self.safe_float(data, 'volume'),
        ]
        messageHash = 'ohlcv:' + symbol + ':' + timeframe
        stored = self.safe_value(self.ohlcvs, symbol)
        if stored is None:
            stored = {}
            self.ohlcvs[symbol] = stored
        storedArray = self.safe_value(stored, timeframe)
        if storedArray is None:
            limit = self.safe_integer(self.options, 'OHLCVLimit', 1000)
            storedArray = ArrayCacheByTimestamp(limit)
            stored[timeframe] = storedArray
        storedArray.append(parsed)
        client.resolve(storedArray, messageHash)
        return message

    async def watch_orders(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Order]:
        """
        watches information on multiple orders made by the user

        https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams

        :param str [symbol]: unified market symbol of the market orders were made in
        :param int [since]: the earliest time in ms to fetch orders for
        :param int [limit]: the maximum number of order structures to retrieve
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict[]: a list of `order structures <https://docs.ccxt.com/#/?id=order-structure>`
        """
        await self.load_markets()
        await self.authenticate()
        url = self.get_url(True)
        messageHash = 'orders'
        topic = 'orders'
        request: dict = {
            'op': 'subscribe',
            'args': [topic],
        }
        orders = await self.watch(url, messageHash, request, messageHash)
        if self.newUpdates:
            limit = orders.getLimit(symbol, limit)
        return self.filter_by_symbol_since_limit(orders, symbol, since, limit, True)

    async def un_watch_orders(self, symbol: Str = None, params={}) -> Any:
        """
        unwatch orders

        https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams

        :param str [symbol]: unified market symbol
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns any: status
        """
        await self.load_markets()
        url = self.get_url(True)
        topic = 'orders'
        request: dict = {
            'op': 'unsubscribe',
            'args': [topic],
        }
        return await self.watch(url, 'unsubscribe:orders', request, 'unsubscribe:orders')

    def handle_orders(self, client: Client, message: Any) -> Any:
        #
        # {
        #   "topic": "orders",
        #   "data": [{
        #     "orderId": "order123",
        #     "clientOrderId": "client456",
        #     "symbol": "BTC-PERP",
        #     "orderType": "LIMIT",
        #     "side": "BUY",
        #     "price": "28000.0",
        #     "size": "1.0",
        #     "filledSize": "0.5",
        #     "avgFillPrice": "28000.0",
        #     "status": "PARTIAL_FILLED",
        #     "triggerPrice": null,
        #     "timestamp": 1680751558529
        #   }]
        # }
        #
        data = self.safe_list(message, 'data', [])
        ordersArray = []
        for i in range(0, len(data)):
            order = self.parse_order(data[i])
            ordersArray.append(order)
        stored = self.orders
        if stored is None:
            limit = self.safe_integer(self.options, 'ordersLimit', 1000)
            stored = ArrayCacheBySymbolById(limit)
            self.orders = stored
        for i in range(0, len(ordersArray)):
            stored.append(ordersArray[i])
        messageHash = 'orders'
        client.resolve(stored, messageHash)
        return message

    async def watch_my_trades(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Trade]:
        """
        watches information on multiple trades made by the user

        https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams

        :param str [symbol]: unified market symbol of the market trades were made in
        :param int [since]: the earliest time in ms to fetch trades for
        :param int [limit]: the maximum number of trade structures to retrieve
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict[]: a list of `trade structures <https://docs.ccxt.com/#/?id=trade-structure>`
        """
        await self.load_markets()
        await self.authenticate()
        url = self.get_url(True)
        messageHash = 'myTrades'
        topic = 'fills'
        request: dict = {
            'op': 'subscribe',
            'args': [topic],
        }
        trades = await self.watch(url, messageHash, request, messageHash)
        if self.newUpdates:
            limit = trades.getLimit(symbol, limit)
        return self.filter_by_symbol_since_limit(trades, symbol, since, limit, True)

    async def un_watch_my_trades(self, symbol: Str = None, params={}) -> Any:
        """
        unwatch my trades

        https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams

        :param str [symbol]: unified market symbol
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns any: status
        """
        await self.load_markets()
        url = self.get_url(True)
        topic = 'fills'
        request: dict = {
            'op': 'unsubscribe',
            'args': [topic],
        }
        return await self.watch(url, 'unsubscribe:myTrades', request, 'unsubscribe:myTrades')

    def handle_my_trades(self, client: Client, message: Any) -> Any:
        #
        # {
        #   "topic": "fills",
        #   "data": [{
        #     "orderId": "order123",
        #     "tradeId": "trade789",
        #     "symbol": "BTC-PERP",
        #     "side": "BUY",
        #     "price": "28000.0",
        #     "size": "0.5",
        #     "fee": "0.00005",
        #     "feeCurrency": "BTC",
        #     "feeRate": "0.0001",
        #     "maker": False,
        #     "timestamp": 1680751558529
        #   }]
        # }
        #
        data = self.safe_list(message, 'data', [])
        tradesArray = []
        for i in range(0, len(data)):
            trade = self.parse_order(data[i])
            tradesArray.append(trade)
        stored = self.myTrades
        if stored is None:
            limit = self.safe_integer(self.options, 'tradesLimit', 1000)
            stored = ArrayCacheBySymbolById(limit)
            self.myTrades = stored
        for i in range(0, len(tradesArray)):
            stored.append(tradesArray[i])
        messageHash = 'myTrades'
        client.resolve(stored, messageHash)
        return message

    async def watch_positions(self, symbols: Strings = None, since: Int = None, params={}) -> List[Position]:
        """
        watch all open positions

        https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams

        :param str[]|None symbols: list of unified market symbols
        :param int [since]: the earliest time in ms to fetch positions for
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict[]: a list of `position structures <https://docs.ccxt.com/#/?id=position-structure>`
        """
        await self.load_markets()
        await self.authenticate()
        symbols = self.market_symbols(symbols, None, False)
        url = self.get_url(True)
        messageHash = 'positionsV3'
        topic = 'positionsV3'
        options = self.safe_value(self.options, 'watchPositions', {})
        fetchPositionsSnapshot = self.safe_bool(options, 'fetchPositionsSnapshot', True)
        awaitPositionsSnapshot = self.safe_bool(options, 'awaitPositionsSnapshot', True)
        if fetchPositionsSnapshot and awaitPositionsSnapshot:
            snapshot = await self.fetch_positions(symbols)
            if self.positions is None:
                self.positions = ArrayCacheBySymbolById()
            for i in range(0, len(snapshot)):
                self.positions.append(snapshot[i])
        request: dict = {
            'op': 'subscribe',
            'args': [topic],
        }
        positions = await self.watch(url, messageHash, request, messageHash)
        if self.newUpdates:
            return positions
        return self.filter_by_symbols_since_limit(positions, symbols, since, None, True)

    async def un_watch_positions(self, symbols: Strings = None, params={}) -> Any:
        """
        unwatch positions

        https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams

        :param str[] [symbols]: list of unified market symbols
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns any: status
        """
        await self.load_markets()
        url = self.get_url(True)
        topic = 'positionsV3'
        request: dict = {
            'op': 'unsubscribe',
            'args': [topic],
        }
        return await self.watch(url, 'unsubscribe:positionsV3', request, 'unsubscribe:positionsV3')

    def handle_positions(self, client: Client, message: Any) -> Any:
        #
        # {
        #   "topic": "positionsV3",
        #   "data": [{
        #     "marketName": "QA-PERP-USDT",
        #     "entryPrice": 1500,
        #     "markedPrice": 1500,
        #     "liquidationPrice": 0,
        #     "unrealizedProfitLoss": 0,
        #     "totalContracts": 666,
        #     "marginTypeName": "FUTURES_MARGIN_CROSS",
        #     "currentLeverage": 0.0999085912,
        #     "positionId": "QA-PERP-USDT",
        #     "positionMode": "ONE_WAY",
        #     "positionDirection": "LONG",
        #     "contractSize": 0.01,
        #     "totalValue": 9990
        #   }]
        # }
        #
        data = self.safe_list(message, 'data', [])
        positionsArray = []
        for i in range(0, len(data)):
            position = self.parse_position(data[i])
            positionsArray.append(position)
        if self.positions is None:
            self.positions = ArrayCacheBySymbolById()
        for i in range(0, len(positionsArray)):
            self.positions.append(positionsArray[i])
        messageHash = 'positionsV3'
        client.resolve(self.positions, messageHash)
        return message

    async def watch_balance(self, params={}) -> Balances:
        """
        watch balance and get the amount of funds available for trading or funds locked in orders

        https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a `balance structure <https://docs.ccxt.com/#/?id=balance-structure>`
        """
        await self.load_markets()
        await self.authenticate()
        url = self.get_url(True)
        messageHash = 'balance'
        topic = 'wallet'
        request: dict = {
            'op': 'subscribe',
            'args': [topic],
        }
        return await self.watch(url, messageHash, request, messageHash)

    async def un_watch_balance(self, params={}) -> Any:
        """
        unwatch balance

        https://btsecom.github.io/docs/futuresV2_3/en/#websocket-streams

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns any: status
        """
        await self.load_markets()
        url = self.get_url(True)
        topic = 'wallet'
        request: dict = {
            'op': 'unsubscribe',
            'args': [topic],
        }
        return await self.watch(url, 'unsubscribe:balance', request, 'unsubscribe:balance')

    def handle_balance(self, client: Client, message: Any) -> Any:
        #
        # {
        #   "topic": "wallet",
        #   "data": [{
        #     "currency": "USDT",
        #     "total": "10000.0",
        #     "available": "8500.0",
        #     "reserved": "1500.0",
        #     "timestamp": 1680751558529
        #   }, {
        #     "currency": "BTC",
        #     "total": "0.5",
        #     "available": "0.3",
        #     "reserved": "0.2",
        #     "timestamp": 1680751558529
        #   }]
        # }
        #
        data = self.safe_list(message, 'data', [])
        self.balance['info'] = message
        for i in range(0, len(data)):
            balance = data[i]
            currencyId = self.safe_string(balance, 'currency')
            code = self.safe_currency_code(currencyId)
            account = self.account()
            account['free'] = self.safe_string(balance, 'available')
            account['used'] = self.safe_string(balance, 'reserved')
            account['total'] = self.safe_string(balance, 'total')
            self.balance[code] = account
        self.balance = self.safe_balance(self.balance)
        messageHash = 'balance'
        client.resolve(self.balance, messageHash)
        return message
